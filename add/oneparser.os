//
// Включает программный код https://github.com/khorevaa/OneShell


#Область Константы

Перем Дескрипторы;                  // Перечисление
Перем Лексемы;                    // Перечисление
Перем ВидыОбъектов;               // Перечисление
Перем ВидыРазделителей;             // Перечисление
Перем УнарныеОперации;           // array (one of Лексемы)
Перем ПростойЛитерал;             // array (one of Лексемы)
Перем ОператорыСравнения;       // array (one of Лексемы)
Перем ИгнорируемыеЛексемы;             // array (one of Лексемы)
Перем НачальныеЛексемыВыражений; // array (one of Лексемы)
Перем Операторы;                 // Структура
Перем ПустойМассив;                // array
Перем Подробно;

#КонецОбласти // Константы

#Область Инициализация

Процедура Инициализация()

	СоздатьПеречисления();

	УнарныеОперации = Новый Массив;
	УнарныеОперации.Добавить(Лексемы.Добавить);
	УнарныеОперации.Добавить(Лексемы.Вычесть);
	УнарныеОперации.Добавить(Лексемы.НЕ);

	ПростойЛитерал = Новый Массив;
	ПростойЛитерал.Добавить(Лексемы.Число);
	ПростойЛитерал.Добавить(Лексемы.Строка);
	ПростойЛитерал.Добавить(Лексемы.ДатаВремя);
	ПростойЛитерал.Добавить(Лексемы.Истина);
	ПростойЛитерал.Добавить(Лексемы.Ложь);
	ПростойЛитерал.Добавить(Лексемы.Неопределено);

	ОператорыСравнения = Новый Массив;
	ОператорыСравнения.Добавить(Лексемы.Равно);
	ОператорыСравнения.Добавить(Лексемы.НеРавно);
	ОператорыСравнения.Добавить(Лексемы.Меньше);
	ОператорыСравнения.Добавить(Лексемы.Больше);
	ОператорыСравнения.Добавить(Лексемы.МеньшеИлиРавно);
	ОператорыСравнения.Добавить(Лексемы.БольшеИлиРавно);

	ИгнорируемыеЛексемы = Новый Массив;
	ИгнорируемыеЛексемы.Добавить(Лексемы.Комментарий);
	ИгнорируемыеЛексемы.Добавить(Лексемы.Препроцессор);
	ИгнорируемыеЛексемы.Добавить(Лексемы.Директива);

	НачальныеЛексемыВыражений = Новый Массив;
	НачальныеЛексемыВыражений.Добавить(Лексемы.Добавить);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Вычесть);
	НачальныеЛексемыВыражений.Добавить(Лексемы.НЕ);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Идентификатор);
	НачальныеЛексемыВыражений.Добавить(Лексемы.ОткрСкобкаОбычная);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Число);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Строка);
	НачальныеЛексемыВыражений.Добавить(Лексемы.ДатаВремя);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Вопрос);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Новый);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Истина);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Ложь);
	НачальныеЛексемыВыражений.Добавить(Лексемы.Неопределено);

	Операторы = Новый Структура(
		"Равно, НеРавно, Меньше, Больше, МеньшеИлиРавно, БольшеИлиРавно, Добавить, Вычесть, Умножить, Разделить, Остаток, ИЛИ, И, НЕ",
		"=", "<>", "<", ">", "<=", ">=", "+", "-", "*", "/", "%", "ИЛИ", "И", "НЕ"
	);

	ПустойМассив = Новый Массив;

КонецПроцедуры // Инициализация()

Процедура СоздатьПеречисления()
	Дескрипторы = Дескрипторы();
	Лексемы = Лексемы(Дескрипторы);
	ВидыОбъектов = ВидыОбъектов();
КонецПроцедуры // СоздатьПеречисления()

#КонецОбласти // Инициализация

#Область Перечисления

Функция Дескрипторы() Экспорт
	Перем Дескрипторы;

	Дескрипторы = Перечисление(Новый Структура,
		"Если.If, Тогда.Then, ИначеЕсли.ElsIf, Иначе.Else, КонецЕсли.EndIf,
		|Для.For, Каждого.Each, Из.In, По.To, Пока.While, Цикл.Do, КонецЦикла.EndDo,
		|Процедура.Procedure, КонецПроцедуры.EndProcedure, Функция.Function, КонецФункции.EndFunction,
		|Перем.Var, Знач.Val, Возврат.Return, Продолжить.Continue, Прервать.Break,
		|И.And, ИЛИ.Or, НЕ.Not,
		|Попытка.Try, Исключение.Except, ВызватьИсключение.Raise, КонецПопытки.EndTry,
		|Новый.Новый, Выполнить.Execute, Экспорт.Export,
		|Истина.True, Ложь.False, Неопределено.Undefined,
		|Выбор.Case, Когда.When, КонецВыбора.EndCase" // Новый Дескрипторы
	);

	Возврат Дескрипторы;

КонецФункции // Дескрипторы()

Функция Лексемы(Дескрипторы = Неопределено) Экспорт
	Перем Лексемы;

	Если Дескрипторы = Неопределено Тогда
		Дескрипторы = Дескрипторы();
	КонецЕсли;

	Лексемы = Перечисление(Дескрипторы(),

		// Literals

		"Идентификатор, Число, Строка, ДатаВремя,
		// parts of strings
		|НачалоСтроки, СодержимоеСтроки, КонецСтроки,

		// Операторы

		// =   <>    <    >   <=   >=    +    -    *    /    %
		|Равно, НеРавно, Меньше, Больше, МеньшеИлиРавно, БольшеИлиРавно, Добавить, Вычесть, Умножить, Разделить, Остаток,
		//    (       )       [       ]       {       }
		|ОткрСкобкаОбычная, ЗакрСкобкаОбычная, ОткрСкобкаКвадратная, ЗакрСкобкаКвадратная, ОткрСкобкаФигурная, ЗакрСкобкаФигурная,
		//     ?      ,       .      :          ;
		|Вопрос, Запятая, Точка, Двоеточие, ТочкаСЗапятой,

		// Новый Определения

		//      +=
		|Увеличить,

		// Other

		//         //             #          &
		|КонецФайла, Комментарий, Препроцессор, Директива"

	);

	Возврат Лексемы;

КонецФункции // Лексемы()

Функция ВидыОбъектов() Экспорт
	Перем ВидыОбъектов;

	ВидыОбъектов = Перечисление(Новый Структура,
		"Переменная,"
		"Параметр,"
		"Процедура,"
		"Функция,"
		"Конструктор,"
		"Неизвестный,"
	);

	Возврат ВидыОбъектов;

КонецФункции // ВидыОбъектов()

Функция ВидыРазделителей() Экспорт
	Перем ВидыРазделителей;

	ВидыРазделителей = Перечисление(Новый Структура,
		"Идентификатор,"
		"Индекс,"
		"Вызов,"
	);

	Возврат ВидыРазделителей;

КонецФункции // ВидыРазделителей()

Функция Перечисление(Структура, Ключи)
	Перем СписокЭлементов, Значение;

	Для Каждого Элементы Из СтрРазделить(Ключи, ",", Ложь) Цикл
		СписокЭлементов = СтрРазделить(Элементы, ".", Ложь);
		Значение = СокрЛП(СписокЭлементов[0]);
		Для Каждого Элемент Из СписокЭлементов Цикл
			Структура.Вставить(СокрЛП(Элемент), Значение);
		КонецЦикла;
	КонецЦикла;

	Возврат Структура;

КонецФункции // Перечисление()

#КонецОбласти // Перечисления

#Область Разбор

Функция Разбор(Источник) Экспорт
	Перем Разбор;

	Разбор = Новый Структура(
		"Источник," // Строка
		"Длина,"    // Число
		"Позиция,"    // Число
		"Элемент,"    // Строка (one of Лексемы)
		"Литерал,"    // Строка
		"Символ,"   // Строка
		"Строка,"   // Число
		"Столбец" // Число
	);

	Разбор.Источник = Источник;
	Разбор.Длина = СтрДлина(Источник);
	Разбор.Строка = 1;
	Разбор.Столбец = 0;
	Разбор.Позиция = 0;
	Разбор.Литерал = "";

	Инициализация();

	Возврат Разбор;

КонецФункции // Разбор()

Функция Разобрать(Разбор) Экспорт
	Перем Символ, Элемент, Литерал;
	ПропуститьПустоту(Разбор);
	Символ = Разбор.Символ;
	Если ЭтоБуква(Символ) Тогда
		Литерал = РазобратьИдентификатор(Разбор);
		Элемент = Проверить(Литерал);
	ИначеЕсли ЭтоЦифра(Символ) Тогда
		Литерал = РазобратьЧисло(Разбор);
		Элемент = Лексемы.Число;
	ИначеЕсли Символ = """" ИЛИ Символ = "|" Тогда
		Литерал = РазобратьСтроку(Разбор);
		Элемент = ЭлементСтроки(Литерал);
	ИначеЕсли Символ = "'" Тогда
		Литерал = РазобратьДатуВремя(Разбор);
		Элемент = Лексемы.ДатаВремя;
	ИначеЕсли Символ = "=" Тогда
		Элемент = Лексемы.Равно;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "<" Тогда
		Если СледСимвол(Разбор) = "=" Тогда
			Литерал = "<=";
			Элемент = Лексемы.МеньшеИлиРавно;
			СледСимвол(Разбор);
		ИначеЕсли Разбор.Символ = ">" Тогда
			Литерал = "<>";
			Элемент = Лексемы.НеРавно;
			СледСимвол(Разбор);
		Иначе
			Элемент = Лексемы.Меньше;
		КонецЕсли;
	ИначеЕсли Символ = ">" Тогда
		Если СледСимвол(Разбор) = "=" Тогда
			Литерал = ">=";
			Элемент = Лексемы.БольшеИлиРавно;
			СледСимвол(Разбор);
		Иначе
			Элемент = Лексемы.Больше;
		КонецЕсли;
	ИначеЕсли Символ = "+" Тогда
		Если СледСимвол(Разбор) = "=" Тогда
			Литерал = "+=";
			Элемент = Лексемы.Увеличить;
			СледСимвол(Разбор);
		Иначе
			Элемент = Лексемы.Добавить;
		КонецЕсли;
	ИначеЕсли Символ = "-" Тогда
		Элемент = Лексемы.Вычесть;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "*" Тогда
		Элемент = Лексемы.Умножить;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "/" Тогда
		Если СледСимвол(Разбор) = "/" Тогда
			Литерал = РазобратьКомментарий(Разбор);
			Элемент = Лексемы.Комментарий;
		Иначе
			Элемент = Лексемы.Разделить;
		КонецЕсли;
	ИначеЕсли Символ = "%" Тогда
		Элемент = Лексемы.Остаток;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "(" Тогда
		Элемент = Лексемы.ОткрСкобкаОбычная;
		СледСимвол(Разбор);
	ИначеЕсли Символ = ")" Тогда
		Элемент = Лексемы.ЗакрСкобкаОбычная;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "[" Тогда
		Элемент = Лексемы.ОткрСкобкаКвадратная;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "]" Тогда
		Элемент = Лексемы.ЗакрСкобкаКвадратная;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "?" Тогда
		Элемент = Лексемы.Вопрос;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "," Тогда
		Элемент = Лексемы.Запятая;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "." Тогда
		Элемент = Лексемы.Точка;
		СледСимвол(Разбор);
	ИначеЕсли Символ = ":" Тогда
		Элемент = Лексемы.Двоеточие;
		СледСимвол(Разбор);
	ИначеЕсли Символ = ";" Тогда
		Элемент = Лексемы.ТочкаСЗапятой;
		СледСимвол(Разбор);
	ИначеЕсли Символ = "" Тогда
		Элемент = Лексемы.КонецФайла;
	ИначеЕсли Символ = "&" Тогда
		Литерал = РазобратьКомментарий(Разбор);
		Элемент = Лексемы.Директива;
	ИначеЕсли Символ = "#" Тогда
		Литерал = РазобратьКомментарий(Разбор);
		Элемент = Лексемы.Препроцессор;
	Иначе
		Ошибка(Разбор, "Неизвестный Символ");
	КонецЕсли;
	Если ЗначениеЗаполнено(Литерал) Тогда
		Разбор.Литерал = Литерал;
	Иначе
		Разбор.Литерал = Символ;
	КонецЕсли;
	Разбор.Элемент = Элемент;
	Возврат Элемент;
КонецФункции // Разобрать()

Функция СледСимвол(Разбор)
	Если Разбор.Символ <> "" Тогда
		Разбор.Позиция = Разбор.Позиция + 1;
		Разбор.Столбец = Разбор.Столбец + 1;
		Разбор.Символ = Сред(Разбор.Источник, Разбор.Позиция, 1);
	КонецЕсли;
	Возврат Разбор.Символ;
КонецФункции // СледСимвол()

Функция ПропуститьПустоту(Разбор)
	Перем Символ;
	Символ = Разбор.Символ;
	Пока ПустаяСтрока(Символ) И Символ <> "" Цикл
		Если Символ = Символы.ПС Тогда
			Разбор.Строка = Разбор.Строка + 1;
			Разбор.Столбец = 0;
		КонецЕсли;
		Символ = СледСимвол(Разбор);
	КонецЦикла;
КонецФункции // ПропуститьПустоту()

Функция РазобратьКомментарий(Разбор)
	Перем Длина, Символ;
	Длина = 0;
	Символ = СледСимвол(Разбор);
	Пока Символ <> Символы.ПС И Символ <> "" Цикл
		Длина = Длина + 1;
		Символ = СледСимвол(Разбор);
	КонецЦикла;
	Возврат Сред(Разбор.Источник, Разбор.Позиция - Длина, Длина);
КонецФункции // РазобратьКомментарий()

Функция РазобратьИдентификатор(Разбор)
	Перем Длина, Символ;
	Длина = 1;
	Символ = СледСимвол(Разбор);
	Пока ЭтоБуква(Символ) ИЛИ ЭтоЦифра(Символ) Цикл
		Длина = Длина + 1;
		Символ = СледСимвол(Разбор);
	КонецЦикла;
	Возврат Сред(Разбор.Источник, Разбор.Позиция - Длина, Длина);
КонецФункции // РазобратьИдентификатор()

Функция РазобратьЧисло(Разбор)
	Перем Длина;
	Длина = РазобратьЧислоДлин(Разбор); // Длина >= 1
	Если Разбор.Символ = "." Тогда
		Длина = Длина + РазобратьЧислоДлин(Разбор);
	КонецЕсли;
	Возврат Сред(Разбор.Источник, Разбор.Позиция - Длина, Длина);
КонецФункции // РазобратьЧисло()

Функция РазобратьЧислоДлин(Разбор)
	Перем Длина;
	Длина = 1;
	Пока ЭтоЦифра(СледСимвол(Разбор)) Цикл
		Длина = Длина + 1;
	КонецЦикла;
	Возврат Длина;
КонецФункции // РазобратьЧислоДлин()

Функция РазобратьСтроку(Разбор)
	Перем Длина;
	Длина = РазобратьСтрокуДлин(Разбор);
	Пока СледСимвол(Разбор) = """" Цикл
		Длина = Длина + РазобратьСтрокуДлин(Разбор);
	КонецЦикла;
	Возврат Сред(Разбор.Источник, Разбор.Позиция - Длина, Длина);
КонецФункции // РазобратьСтроку()

Функция РазобратьСтрокуДлин(Разбор)
	Перем Длина, Символ;
	Длина = 1;
	Символ = СледСимвол(Разбор);
	Пока Символ <> """" И Символ <> Символы.ПС И Символ <> "" Цикл
		Длина = Длина + 1;
		Символ = СледСимвол(Разбор);
	КонецЦикла;
	Если Символ = Символы.ПС Тогда
		Разбор.Строка = Разбор.Строка + 1;
	КонецЕсли;
	Возврат Длина + ?(Символ <> "", 1, 0);
КонецФункции // РазобратьСтрокуДлин()

Функция РазобратьДатуВремя(Разбор)
	Перем Длина, Символ;
	Длина = 1;
	Символ = СледСимвол(Разбор);
	Пока Символ <> "'" И Символ <> "" Цикл
		Длина = Длина + 1;
		Символ = СледСимвол(Разбор);
	КонецЦикла;
	Если Символ = "'" Тогда
		Длина = Длина + 1;
		СледСимвол(Разбор);
	Иначе
		Ошибка(Разбор, "Ожидается `'`");
	КонецЕсли;
	Возврат Сред(Разбор.Источник, Разбор.Позиция - Длина, Длина);
КонецФункции // РазобратьДатуВремя()

#КонецОбласти // Разбор

#Область Дерево

Функция Модуль(Объявления, Определения)
	Перем Модуль;

	Модуль = Новый Структура(
		"Объявления,"      // array (one of Объявления)
		"Определения" // array (one of Определения)
	,
	Объявления, Определения);

	Возврат Модуль;

КонецФункции // Модуль()

#Область Область

Функция Область(Внешний)
	Перем Область;

	Область = Новый Структура(
		"Внешний,"   // Структура (Область)
		"Объекты" // Структура as map[Строка](Объект)
	);

	Область.Внешний = Внешний;
	Область.Объекты = Новый Структура;

	Возврат Область;

КонецФункции // Область()

Функция Объект(Вид, Имя, ТипОбъекта = Неопределено)
	Перем Объект;

	Объект = Новый Структура(
		"Вид," // Строка (one of ВидыОбъектов)
		"Имя" // Строка
	,
	Вид, Имя);

	Если ТипОбъекта <> Неопределено Тогда
		Объект.Вставить("ТипОбъекта", ТипОбъекта); // Структура
	КонецЕсли;

	Возврат Объект;

КонецФункции // Объект()

#КонецОбласти // Область

#Область Объявления

Функция ОбъявленияПеременных(Объект, Инициализация = Ложь, Значение = Неопределено)
	Перем ОбъявленияПеременных;

	ОбъявленияПеременных = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Объект"   // Структура (Объект)
	,
	"ОбъявленияПеременных", Объект);

	Если Инициализация Тогда
		ОбъявленияПеременных.Вставить("Значение", Значение); // Структура (one of Выражения)
	КонецЕсли;

	Возврат ОбъявленияПеременных;

КонецФункции // ОбъявленияПеременных()

Функция ОбъявлениеПеременных(СписокПеременных)
	Перем ОбъявлениеПеременных;

	ОбъявлениеПеременных = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"СписокПеременных"  // array (ОбъявленияПеременных)
	,
	"ОбъявлениеПеременных", СписокПеременных);

	Возврат ОбъявлениеПеременных;

КонецФункции // ОбъявлениеПеременных()

Функция ОбъявлениеПроцедуры(Объект, Объявления, Определения)
	Перем ОбъявлениеПроцедуры;

	ОбъявлениеПроцедуры = Новый Структура(
		"ТипУзла,"   // Строка (ТипОбъекта of this Структура)
		"Объект,"     // Структура (Объект)
		"Объявления,"      // array (one of Объявления)
		"Определения" // array (one of Определения)
	,
	"ОбъявлениеПроцедуры", Объект, Объявления, Определения);

	Возврат ОбъявлениеПроцедуры;

КонецФункции // ОбъявлениеПроцедуры()

Функция ОбъявлениеФункции(Объект, Объявления, Определения)
	Перем ОбъявлениеФункции;

	ОбъявлениеФункции = Новый Структура(
		"ТипУзла,"   // Строка (ТипОбъекта of this Структура)
		"Объект,"     // Структура (Объект)
		"Объявления,"      // array (one of Объявления)
		"Определения" // array (one of Определения)
	,
	"ОбъявлениеФункции", Объект, Объявления, Определения);

	Возврат ОбъявлениеФункции;

КонецФункции // ОбъявлениеФункции()

Функция ОбъявленияПараметров(Объект, Инициализация = Ложь, Значение = Неопределено)
	Перем ОбъявленияПараметров;

	ОбъявленияПараметров = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Объект"   // Структура (Объект)
	,
	"ОбъявленияПараметров", Объект);

	Если Инициализация Тогда
		ОбъявленияПараметров.Вставить("Значение", Значение); // Структура (one of Выражения)
	КонецЕсли;

	Возврат ОбъявленияПараметров;

КонецФункции // ОбъявленияПараметров()

#КонецОбласти // Объявления

#Область Выражения

Функция ПростойЛитерал(Вид, Значение)
	Перем ПростойЛитерал;

	ПростойЛитерал = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Вид,"     // Строка (one of Лексемы)
		"Значение"    // one of basic ТипОбъектаs
	,
	"ПростойЛитерал", Вид, Значение);

	Возврат ПростойЛитерал;

КонецФункции // ПростойЛитерал()

Функция Разделитель(Вид, Значение)
	Перем Разделитель;

	Разделитель = Новый Структура(
		"Вид,"  // Строка (one of ВидыРазделителей)
		"Значение" // Строка ИЛИ array (one of Выражения)
	,
	Вид, Значение);

	Возврат Разделитель;

КонецФункции // Разделитель()

Функция Указатель(Объект, Разделители, Вызов)
	Перем Указатель;

	Указатель = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Объект,"   // Структура (Объект)
		"Вызов"     // boolean
	,
	"Указатель", Объект, Вызов);

	Если Разделители.Количество() > 0 Тогда
		Указатель.Вставить("Разделители", Разделители); // array (Разделитель)
	КонецЕсли;

	Возврат Указатель;

КонецФункции // Указатель()

Функция UnaryExpr(Operator, Operand)
	Перем UnaryExpr;

	UnaryExpr = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Operator," // Строка (one of Лексемы)
		"Operand"  // one of Выражения
	,
	"UnaryExpr", Operator, Operand);

	Возврат UnaryExpr;

КонецФункции // UnaryExpr()

Функция BinaryExpr(Лев, Operator, Прав)
	Перем BinaryExpr;

	BinaryExpr = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Лев,"     // one of Выражения
		"Operator," // Строка (one of Лексемы)
		"Прав"    // one of Выражения
	,
	"BinaryExpr", Лев, Operator, Прав);

	Возврат BinaryExpr;

КонецФункции // BinaryExpr()

Функция RangeExpr(Лев, Прав)
	Перем RangeExpr;

	RangeExpr = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Лев,"     // one of Выражения
		"Прав"    // one of Выражения
	,
	"RangeExpr", Лев, Прав);

	Возврат RangeExpr;

КонецФункции // RangeExpr()

Функция NewExpr(Конструктор)
	Перем NewExpr;

	NewExpr = Новый Структура(
		"ТипУзла,"    // Строка (ТипОбъекта of this Структура)
		"Конструктор" // Структура (Указатель) ИЛИ array (one of Выражения)
	,
	"NewExpr", Конструктор);

	Возврат NewExpr;

КонецФункции // NewExpr()

Функция TernaryExpr(Condition, ThenPart, ElsePart)
	Перем TernaryExpr;

	TernaryExpr = Новый Структура(
		"ТипУзла,"  // Строка (ТипОбъекта of this Структура)
		"Condition," // Структура (one of Выражения)
		"ThenPart,"  // Структура (one of Выражения)
		"ElsePart"   // Структура (one of Выражения)
	,
	"TernaryExpr", Condition, ThenPart, ElsePart);

	Возврат TernaryExpr;

КонецФункции // TernaryExpr()

Функция ParenExpr(Expr)
	Перем ParenExpr;

	ParenExpr = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Expr"     // one of Выражения
	,
	"ParenExpr", Expr);

	Возврат ParenExpr;

КонецФункции // ParenExpr()

#КонецОбласти // Выражения

#Область Определения

Функция AssignStmt(Лев, Прав)
	Перем AssignStmt;

	AssignStmt = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Лев,"     // array (Указатель)
		"Прав"    // array (one of Выражения)
	,
	"AssignStmt", Лев, Прав);

	Возврат AssignStmt;

КонецФункции // AssignStmt()

Функция AddAssignStmt(Лев, Прав)
	Перем AddAssignStmt;

	AddAssignStmt = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Лев,"     // array (Указатель)
		"Прав"    // array (one of Выражения)
	,
	"AddAssignStmt", Лев, Прав);

	Возврат AddAssignStmt;

КонецФункции // AddAssignStmt()

Функция ReturnStmt(ExprList)
	Перем ReturnStmt;

	ReturnStmt = Новый Структура(
		"ТипУзла" // Строка (ТипОбъекта of this Структура)
	,
	"ReturnStmt");

	Если ExprList <> Неопределено Тогда
		ReturnStmt.Вставить("ExprList", ExprList); // array (one of Выражения)
	КонецЕсли;

	Возврат ReturnStmt;

КонецФункции // ReturnStmt()

Функция BreakStmt()
	Перем BreakStmt;

	BreakStmt = Новый Структура(
		"ТипУзла" // Строка (ТипОбъекта of this Структура)
	,
	"BreakStmt");

	Возврат BreakStmt;

КонецФункции // BreakStmt()

Функция ContinueStmt()
	Перем ContinueStmt;

	ContinueStmt = Новый Структура(
		"ТипУзла" // Строка (ТипОбъекта of this Структура)
	,
	"ContinueStmt");

	Возврат ContinueStmt;

КонецФункции // ContinueStmt()

Функция RaiseStmt(Expr = Неопределено)
	Перем RaiseStmt;

	RaiseStmt = Новый Структура(
		"ТипУзла" // Строка (ТипОбъекта of this Структура)
	,
	"RaiseStmt");

	Если Expr <> Неопределено Тогда
		RaiseStmt.Вставить("Expr", Expr); // Структура (one of Выражения)
	КонецЕсли;

	Возврат RaiseStmt;

КонецФункции // RaiseStmt()

Функция ExecuteStmt(Expr)
	Перем ExecuteStmt;

	ExecuteStmt = Новый Структура(
		"ТипУзла," // Строка (ТипОбъекта of this Структура)
		"Expr"     // Структура (one of Выражения)
	,
	"ExecuteStmt", Expr);

	Возврат ExecuteStmt;

КонецФункции // ExecuteStmt()

Функция CallStmt(Указатель)
	Перем CallStmt;

	CallStmt = Новый Структура(
		"ТипУзла,"       // Строка (ТипОбъекта of this Структура)
		"Указатель" // Структура (Указатель)
	,
	"CallStmt", Указатель);

	Возврат CallStmt;

КонецФункции // CallStmt()

Функция IfStmt(Condition, ThenPart, ElsIfPart = Неопределено, ElsePart = Неопределено)
	Перем IfStmt;

	IfStmt = Новый Структура(
		"ТипУзла,"  // Строка (ТипОбъекта of this Структура)
		"Condition," // Структура (one of Выражения)
		"ThenPart"  // array (one of Определения)
	,
	"IfStmt", Condition, ThenPart);

	Если ElsIfPart <> Неопределено Тогда
		IfStmt.Вставить("ElsIfPart", ElsIfPart); // array (IfStmt)
	КонецЕсли;

	Если ElsePart <> Неопределено Тогда
		IfStmt.Вставить("ElsePart", ElsePart); // array (one of Определения)
	КонецЕсли;

	Возврат IfStmt;

КонецФункции // IfStmt()

Функция WhileStmt(Condition, Определения)
	Перем WhileStmt;

	WhileStmt = Новый Структура(
		"ТипУзла,"   // Строка (ТипОбъекта of this Структура)
		"Condition,"  // Структура (one of Выражения)
		"Определения" // array (one of Определения)
	,
	"WhileStmt", Condition, Определения);

	Возврат WhileStmt;

КонецФункции // WhileStmt()

Функция ForStmt(Указатель, Collection, Определения)
	Перем ForStmt;

	ForStmt = Новый Структура(
		"ТипУзла,"       // Строка (ТипОбъекта of this Структура)
		"Указатель," // Структура (Указатель)
		"Collection,"     // Структура (one of Выражения)
		"Определения"     // array (one of Определения)
	,
	"ForStmt", Указатель, Collection, Определения);

	Возврат ForStmt;

КонецФункции // ForStmt()

Функция CaseStmt(Указатель, WhenPart, ElsePart = Неопределено)
	Перем CaseStmt;

	CaseStmt = Новый Структура(
		"ТипУзла,"       // Строка (ТипОбъекта of this Структура)
		"Указатель," // Структура (one of Выражения)
		"WhenPart"       // array (IfStmt)
	,
	"CaseStmt", Указатель, WhenPart);

	Если ElsePart <> Неопределено Тогда
		CaseStmt.Вставить("ElsePart", ElsePart); // array (one of Определения)
	КонецЕсли;

	Возврат CaseStmt;

КонецФункции // CaseStmt()

Функция TryStmt(TryPart, ExceptPart)
	Перем TryStmt;

	TryStmt = Новый Структура(
		"ТипУзла,"   // Строка (ТипОбъекта of this Структура)
		"TryPart,"    // array (one of Определения)
		"ExceptPart" // array (one of Определения)
	,
	"TryStmt", TryPart, ExceptPart);

	Возврат TryStmt;

КонецФункции // TryStmt()

#КонецОбласти // Определения

#Область ТипОбъектаs

Функция Signature(СписокПараметров)
	Перем Signature;

	Signature = Новый Структура(
		"ТипУзла,"  // Строка (ТипОбъекта of this Структура)
		"СписокПараметров" // array (boolean)
	,
	"Signature", СписокПараметров);

	Возврат Signature;
КонецФункции // Signature()

#КонецОбласти // ТипОбъектаs

#КонецОбласти // Дерево

#Область Парсер

Функция Парсер(Источник) Экспорт
	Перем Парсер;

	Парсер = Новый Структура(
		"Разбор," // Структура (Разбор)
		"Элемент,"     // Строка (one of Лексемы)
		"Литерал,"     // Строка
		"Знач,"     // Число, Строка, Дата, Истина, Ложь, Неопределено
		"Область,"   // Структура (Область)
		"Imports," // Структура
		"Модуль,"  // Структура (Модуль)
		"Неизвестный," // Структура as map[Строка](Объект)
		"IsFunc"  // boolean
	);

	Парсер.Разбор = Разбор(Источник);
	Парсер.Область = Область(Неопределено);
	Парсер.Imports = Новый Структура;
	Парсер.Неизвестный = Новый Структура;
	Парсер.IsFunc = Ложь;

	Парсер.Область.Объекты.Вставить("Структура", Объект("Конструктор", "Структура"));

	Возврат Парсер;

КонецФункции // Парсер()

Функция Дальше(Парсер)
	Перем Элемент, Литерал;
	Элемент = Разобрать(Парсер.Разбор);
	Пока ИгнорируемыеЛексемы.Найти(Элемент) <> Неопределено Цикл
		Элемент = Разобрать(Парсер.Разбор);
	КонецЦикла;
	Если Элемент = Лексемы.НачалоСтроки Тогда
		Литерал = ParseString(Парсер);
		Элемент = Лексемы.Строка;
	Иначе
		Литерал = Парсер.Разбор.Литерал;
	КонецЕсли;
	Парсер.Элемент = Элемент;
	Парсер.Литерал = Литерал;
	Парсер.Знач = Значение(Элемент, Литерал);
	Возврат Парсер.Элемент;
КонецФункции // Дальше()

Функция SkipИгнорируемыеЛексемы(Парсер)
	Перем Элемент;
	Элемент = Парсер.Элемент;
	Если ИгнорируемыеЛексемы.Найти(Элемент) <> Неопределено Тогда
		Элемент = Дальше(Парсер);
	КонецЕсли;
	Возврат Элемент;
КонецФункции // SkipИгнорируемыеЛексемы()

Функция FindObject(Парсер, Имя)
	Перем Область, Объект;
	Область = Парсер.Область;
	Область.Объекты.Свойство(Имя, Объект);
	Пока Объект = Неопределено И Область.Внешний <> Неопределено Цикл
		Область = Область.Внешний;
		Область.Объекты.Свойство(Имя, Объект);
	КонецЦикла;
	Возврат Объект;
КонецФункции // FindObject()

Функция OpenScope(Парсер)
	Перем Область;
	Область = Область(Парсер.Область);
	Парсер.Область = Область;
	Возврат Область;
КонецФункции // OpenScope()

Функция CloseScope(Парсер)
	Перем Область;
	Область = Парсер.Область.Внешний;
	Парсер.Область = Область;
	Возврат Область;
КонецФункции // CloseScope()

Функция ParseString(Парсер)
	Перем Разбор, Элемент, Список;
	Разбор = Парсер.Разбор;
	Список = Новый Массив;
	Список.Добавить(Разбор.Литерал);
	Элемент = Разобрать(Разбор);
	Пока Элемент = Лексемы.Комментарий Цикл
		Элемент = Разобрать(Разбор);
	КонецЦикла;
	Пока Элемент = Лексемы.СодержимоеСтроки Цикл
		Список.Добавить(Сред(Разбор.Литерал, 2));
		Элемент = Разобрать(Разбор);
		Пока Элемент = Лексемы.Комментарий Цикл
			Элемент = Разобрать(Разбор);
		КонецЦикла;
	КонецЦикла;
	Сверить(Разбор, Лексемы.КонецСтроки);
	Список.Добавить(Сред(Разбор.Литерал, 2));
	Возврат СтрСоединить(Список);
КонецФункции // ParseString()

Функция ParseUnaryExpr(Парсер)
	Перем Operator;
	Operator = Парсер.Элемент;
	Если УнарныеОперации.Найти(Парсер.Элемент) <> Неопределено Тогда
		Дальше(Парсер);
		Возврат UnaryExpr(Operator, ParseOperand(Парсер));
	ИначеЕсли Парсер.Элемент = Лексемы.КонецФайла Тогда
		Возврат Неопределено;
	КонецЕсли;
	Возврат ParseOperand(Парсер);
КонецФункции // ParseUnaryExpr()

Функция ParseOperand(Парсер)
	Перем Элемент, СписокСтр, Operand;
	Элемент = Парсер.Элемент;
	Если ПростойЛитерал.Найти(Элемент) <> Неопределено Тогда
		Если Элемент = Лексемы.Строка Тогда
			СписокСтр = Новый Массив;
			СписокСтр.Добавить(Парсер.Знач);
			Пока Дальше(Парсер) = Лексемы.Строка Цикл
				СписокСтр.Добавить(Парсер.Знач);
			КонецЦикла;
			Operand = ПростойЛитерал(Элемент, СтрСоединить(СписокСтр, Символы.ПС));
		Иначе
			Operand = ПростойЛитерал(Элемент, Парсер.Знач);
			Дальше(Парсер);
		КонецЕсли;
	ИначеЕсли Элемент = Лексемы.Идентификатор Тогда
		Operand = ПарситьУказатель(Парсер);
	ИначеЕсли Элемент = Лексемы.ОткрСкобкаОбычная Тогда
		Дальше(Парсер);
		Operand = ParenExpr(ParseExpression(Парсер));
		Сверить(Парсер, Лексемы.ЗакрСкобкаОбычная);
		Дальше(Парсер);
	ИначеЕсли Элемент = Лексемы.Новый Тогда
		Operand = ParseNewExpr(Парсер);
	ИначеЕсли Элемент = Лексемы.Вопрос Тогда
		Operand = ParseTernaryExpr(Парсер);
	Иначе
		ВызватьИсключение "Ожидается operand";
	КонецЕсли;
	Возврат Operand;
КонецФункции // ParseOperand()

Функция ParseNewExpr(Парсер)
	Перем Элемент, Конструктор;
	Элемент = Дальше(Парсер);
	Если Элемент = Лексемы.ОткрСкобкаОбычная Тогда
		Элемент = Дальше(Парсер);
		Если Элемент = Лексемы.ЗакрСкобкаОбычная Тогда
			Конструктор = ПустойМассив;
		Иначе
			Конструктор = ParseExprList(Парсер, Истина);
		КонецЕсли;
		Сверить(Парсер, Лексемы.ЗакрСкобкаОбычная);
		Дальше(Парсер);
	Иначе
		Конструктор = ПарситьУказатель(Парсер);
	КонецЕсли;
	Возврат NewExpr(Конструктор);
КонецФункции // ParseNewExpr()

Функция ПарситьУказатель(Парсер, AllowNewVar = Ложь)
	Перем Объект, Разделитель, Список, Вызов, Имя, Столбец;
	Объект = ParseQualident(Парсер);
	Если Объект = Неопределено Тогда
		Столбец = Парсер.Разбор.Столбец - СтрДлина(Парсер.Литерал);
	КонецЕсли;
	Имя = Парсер.Литерал;
	Список = Новый Массив;
	Вызов = Ложь;
	Разделитель = ParseSelector(Парсер);
	Пока Разделитель <> Неопределено Цикл
		Список.Добавить(Разделитель);
		Вызов = (Разделитель.Вид = "Вызов");
		Разделитель = ParseSelector(Парсер);
	КонецЦикла;
	Если Объект = Неопределено Тогда
		Если Вызов Тогда
			Если НЕ Парсер.Неизвестный.Свойство(Имя, Объект) Тогда
				Объект = Объект("Неизвестный", Имя);
				Парсер.Неизвестный.Вставить(Имя, Объект);
			КонецЕсли;
		Иначе
			Если AllowNewVar Тогда
				Объект = Объект(ВидыОбъектов.Переменная, Имя);
				Парсер.Область.Объекты.Вставить(Имя, Объект);
			Иначе
				Объект = Объект("Неизвестный", Имя);
				Если Подробно Тогда
					Ошибка(Парсер.Разбор, СтрШаблон("Необъявленный идентификатор `%1`", Имя), Столбец);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат Указатель(Объект, Список, Вызов);
КонецФункции // ПарситьУказатель()

Функция ParseDesignatorExprList(Парсер, AllowNewVar = Ложь)
	Перем Список;
	Список = Новый Массив;
	Список.Добавить(ПарситьУказатель(Парсер, AllowNewVar));
	Пока Парсер.Элемент = Лексемы.Запятая Цикл
		Дальше(Парсер);
		Список.Добавить(ПарситьУказатель(Парсер, AllowNewVar));
	КонецЦикла;
	Возврат Список;
КонецФункции // ParseDesignatorExprList()

Функция ParseQualident(Парсер)
	Перем Модуль, Объект;
	Парсер.Imports.Свойство(Парсер.Литерал, Модуль);
	Если Модуль <> Неопределено Тогда
		Дальше(Парсер);
		Сверить(Парсер, Лексемы.Точка);
		Дальше(Парсер);
		Сверить(Парсер, Лексемы.Идентификатор);
		Модуль.Объекты.Свойство(Парсер.Литерал, Объект);
	Иначе
		Объект = FindObject(Парсер, Парсер.Литерал);
	КонецЕсли;
	Возврат Объект;
КонецФункции // ParseQualident()

Функция ParseSelector(Парсер)
	Перем Элемент, Значение;
	Элемент = Дальше(Парсер);
	Если Элемент = Лексемы.Точка Тогда
		Дальше(Парсер);
		Если НЕ Дескрипторы.Свойство(Парсер.Литерал) Тогда
			Сверить(Парсер, Лексемы.Идентификатор);
		КонецЕсли;
		Значение = Парсер.Литерал;
		Возврат Разделитель("Идентификатор", Значение);
	ИначеЕсли Элемент = Лексемы.ОткрСкобкаКвадратная Тогда
		Элемент = Дальше(Парсер);
		Если Элемент = Лексемы.ЗакрСкобкаКвадратная Тогда
			Ошибка(Парсер.Разбор, "Ожидается expression",, Истина);
		КонецЕсли;
		Значение = ParseExprList(Парсер);
		Сверить(Парсер, Лексемы.ЗакрСкобкаКвадратная);
		Возврат Разделитель("Индекс", Значение);
	ИначеЕсли Элемент = Лексемы.ОткрСкобкаОбычная Тогда
		Элемент = Дальше(Парсер);
		Если Элемент = Лексемы.ЗакрСкобкаОбычная Тогда
			Значение = ПустойМассив;
		Иначе
			Значение = ParseExprList(Парсер, Истина);
		КонецЕсли;
		Сверить(Парсер, Лексемы.ЗакрСкобкаОбычная);
		Возврат Разделитель("Вызов", Значение);
	КонецЕсли;
	Возврат Неопределено;
КонецФункции // ParseSelector()

Функция ParseExpression(Парсер)
	Перем Expr, Operator;
	Expr = ParseAndExpr(Парсер);
	Пока Парсер.Элемент = "ИЛИ" Цикл
		Operator = Парсер.Элемент;
		Дальше(Парсер);
		Expr = BinaryExpr(Expr, Operator, ParseAndExpr(Парсер));
	КонецЦикла;
	Возврат Expr;
КонецФункции // ParseExpression()

Функция ParseAndExpr(Парсер)
	Перем Expr, Operator;
	Expr = ParseRelExpr(Парсер);
	Пока Парсер.Элемент = "И" Цикл
		Operator = Парсер.Элемент;
		Дальше(Парсер);
		Expr = BinaryExpr(Expr, Operator, ParseRelExpr(Парсер));
	КонецЦикла;
	Возврат Expr;
КонецФункции // ParseAndExpr()

Функция ParseRelExpr(Парсер)
	Перем Expr, Operator;
	Expr = ParseAddExpr(Парсер);
	Пока ОператорыСравнения.Найти(Парсер.Элемент) <> Неопределено Цикл
		Operator = Парсер.Элемент;
		Дальше(Парсер);
		Expr = BinaryExpr(Expr, Operator, ParseAddExpr(Парсер));
	КонецЦикла;
	Возврат Expr;
КонецФункции // ParseRelExpr()

Функция ParseAddExpr(Парсер)
	Перем Expr, Operator;
	Expr = ParseMulExpr(Парсер);
	Пока Парсер.Элемент = Лексемы.Добавить ИЛИ Парсер.Элемент = Лексемы.Вычесть Цикл
		Operator = Парсер.Элемент;
		Дальше(Парсер);
		Expr = BinaryExpr(Expr, Operator, ParseMulExpr(Парсер));
	КонецЦикла;
	Возврат Expr;
КонецФункции // ParseAddExpr()

Функция ParseMulExpr(Парсер)
	Перем Expr, Operator;
	Expr = ParseUnaryExpr(Парсер);
	Пока Парсер.Элемент = Лексемы.Умножить ИЛИ Парсер.Элемент = Лексемы.Разделить ИЛИ Парсер.Элемент = Лексемы.Остаток Цикл
		Operator = Парсер.Элемент;
		Дальше(Парсер);
		Expr = BinaryExpr(Expr, Operator, ParseUnaryExpr(Парсер));
	КонецЦикла;
	Возврат Expr;
КонецФункции // ParseMulExpr()

Функция ParseExprList(Парсер, IsArguments = Ложь)
	Перем ExprList, СверитьExpression;
	ExprList = Новый Массив;
	Если IsArguments Тогда
		СверитьExpression = Истина;
		Пока СверитьExpression Цикл
			Если НачальныеЛексемыВыражений.Найти(Парсер.Элемент) <> Неопределено Тогда
				ExprList.Добавить(ParseExpression(Парсер));
			Иначе
				ExprList.Добавить(ПростойЛитерал(Лексемы.Неопределено, Неопределено));
			КонецЕсли;
			Если Парсер.Элемент = Лексемы.Запятая Тогда
				Дальше(Парсер);
			Иначе
				СверитьExpression = Ложь;
			КонецЕсли;
		КонецЦикла;
	Иначе
		Если Парсер.Элемент = Лексемы.Запятая Тогда
			ExprList.Добавить(Неопределено);
		Иначе
			ExprList.Добавить(ParseExpression(Парсер));
		КонецЕсли;
		Пока Парсер.Элемент = Лексемы.Запятая Цикл
			Дальше(Парсер);
			Пока Парсер.Элемент = Лексемы.Запятая Цикл
				ExprList.Добавить(Неопределено);
				Дальше(Парсер);
			КонецЦикла;
			ExprList.Добавить(ParseExpression(Парсер));
		КонецЦикла;
	КонецЕсли;
	Возврат ExprList;
КонецФункции // ParseExprList()

Функция ParseTernaryExpr(Парсер)
	Перем Condition, ThenPart, ElsePart;
	Дальше(Парсер);
	Сверить(Парсер, Лексемы.ОткрСкобкаОбычная);
	Дальше(Парсер);
	Condition = ParseExpression(Парсер);
	Сверить(Парсер, Лексемы.Запятая);
	Дальше(Парсер);
	ThenPart = ParseExpression(Парсер);
	Сверить(Парсер, Лексемы.Запятая);
	Дальше(Парсер);
	ElsePart = ParseExpression(Парсер);
	Сверить(Парсер, Лексемы.ЗакрСкобкаОбычная);
	Дальше(Парсер);
	Возврат TernaryExpr(Condition, ThenPart, ElsePart);
КонецФункции // ParseTernaryExpr()

Функция ParseОбъявлениеФункции(Парсер)
	Перем Область, Объект, Имя, Объявления;
	Дальше(Парсер);
	Сверить(Парсер, Лексемы.Идентификатор);
	ScopeObjects = Парсер.Область.Объекты;
	OpenScope(Парсер);
	Имя = Парсер.Литерал;
	Дальше(Парсер);
	Если Парсер.Неизвестный.Свойство(Имя, Объект) Тогда
		Объект.Вид = ВидыОбъектов.Функция;
		Объект.Вставить("ТипОбъекта", ParseSignature(Парсер));
		Парсер.Неизвестный.Delete(Имя);
	Иначе
		Объект = Объект(ВидыОбъектов.Функция, Имя, ParseSignature(Парсер));
	КонецЕсли;
	ScopeObjects.Вставить(Имя, Объект);
	Объявления = ParseVarDecls(Парсер);
	Парсер.IsFunc = Истина;
	Определения = ParseStatements(Парсер);
	Парсер.IsFunc = Ложь;
	Сверить(Парсер, Лексемы.КонецФункции);
	CloseScope(Парсер);
	Дальше(Парсер);
	Возврат ОбъявлениеФункции(Объект, Объявления, Определения);
КонецФункции // ParseОбъявлениеФункции()

Функция ParseSignature(Парсер)
	Перем СписокПараметров;
	Сверить(Парсер, Лексемы.ОткрСкобкаОбычная);
	Дальше(Парсер);
	Если Парсер.Элемент = Лексемы.ЗакрСкобкаОбычная Тогда
		СписокПараметров = ПустойМассив;
	Иначе
		СписокПараметров = ПарситьСписокПараметров(Парсер);
	КонецЕсли;
	Сверить(Парсер, Лексемы.ЗакрСкобкаОбычная);
	Дальше(Парсер);
	Если Парсер.Элемент = Лексемы.Экспорт Тогда
		Если Подробно Тогда
			Ошибка(Парсер.Разбор, "keyword `Экспорт` ignored");
		КонецЕсли;
		Дальше(Парсер);
	КонецЕсли;
	Возврат Signature(СписокПараметров);
КонецФункции // ParseSignature()

Функция ParseОбъявлениеПроцедуры(Парсер)
	Перем Область, Объект, Имя, Объявления;
	Дальше(Парсер);
	Сверить(Парсер, Лексемы.Идентификатор);
	ScopeObjects = Парсер.Область.Объекты;
	OpenScope(Парсер);
	Имя = Парсер.Литерал;
	Дальше(Парсер);
	Если Парсер.Неизвестный.Свойство(Имя, Объект) Тогда
		Объект.Вид = ВидыОбъектов.Процедура;
		Объект.Вставить("ТипОбъекта", ParseSignature(Парсер));
		Парсер.Неизвестный.Delete(Имя);
	Иначе
		Объект = Объект(ВидыОбъектов.Процедура, Имя, ParseSignature(Парсер));
	КонецЕсли;
	ScopeObjects.Вставить(Имя, Объект);
	Объявления = ParseVarDecls(Парсер);
	Определения = ParseStatements(Парсер);
	Сверить(Парсер, Лексемы.КонецПроцедуры);
	CloseScope(Парсер);
	Дальше(Парсер);
	Возврат ОбъявлениеПроцедуры(Объект, Объявления, Определения);
КонецФункции // ParseОбъявлениеПроцедуры()

Функция ParseReturnStmt(Парсер)
	Перем ExprList;
	Дальше(Парсер);
	Если Парсер.IsFunc Тогда
		ExprList = ParseExprList(Парсер);
	КонецЕсли;
	Возврат ReturnStmt(ExprList);
КонецФункции // ParseReturnStmt()

Функция ParseОбъявлениеПеременных(Парсер)
	Перем СписокПеременных;
	СписокПеременных = Новый Массив;
	СписокПеременных.Добавить(ПарситьОбъявленияПеременных(Парсер));
	Пока Парсер.Элемент = Лексемы.Запятая Цикл
		Дальше(Парсер);
		СписокПеременных.Добавить(ПарситьОбъявленияПеременных(Парсер));
	КонецЦикла;
	Если Парсер.Элемент = Лексемы.Экспорт Тогда
		Если Подробно Тогда
			Ошибка(Парсер.Разбор, "Ключевое слово `Экспорт` пропущено");
		КонецЕсли;
		Дальше(Парсер);
	КонецЕсли;
	Возврат ОбъявлениеПеременных(СписокПеременных);
КонецФункции // ParseОбъявлениеПеременных()

Функция ПарситьОбъявленияПеременных(Парсер)
	Перем Элемент, Имя, Объект, ОбъявленияПеременных;
	Сверить(Парсер, Лексемы.Идентификатор);
	Имя = Парсер.Литерал;
	Элемент = Дальше(Парсер);
	Если Элемент = Лексемы.Равно Тогда
		Элемент = Дальше(Парсер);
		Если ПростойЛитерал.Найти(Элемент) = Неопределено Тогда
			Ошибка(Парсер.Разбор, "Ожидается basic literal");
		КонецЕсли;
		Объект = Объект(ВидыОбъектов.Переменная, Имя, Элемент);
		ОбъявленияПеременных = ОбъявленияПеременных(Объект, Истина, ParseOperand(Парсер));
	Иначе
		Объект = Объект(ВидыОбъектов.Переменная, Имя, Неопределено);
		ОбъявленияПеременных = ОбъявленияПеременных(Объект);
	КонецЕсли;
	Парсер.Область.Объекты.Вставить(Имя, Объект);
	Возврат ОбъявленияПеременных;
КонецФункции // ПарситьОбъявленияПеременных()

Функция ПарситьСписокПараметров(Парсер)
	Перем СписокПараметров;
	СписокПараметров = Новый Массив;
	СписокПараметров.Добавить(ПарситьОбъявленияПараметров(Парсер));
	Пока Парсер.Элемент = Лексемы.Запятая Цикл
		Дальше(Парсер);
		СписокПараметров.Добавить(ПарситьОбъявленияПараметров(Парсер));
	КонецЦикла;
	Возврат СписокПараметров;
КонецФункции // ПарситьСписокПараметров()

Функция ПарситьОбъявленияПараметров(Парсер)
	Перем Элемент, Имя, Объект, ОбъявленияПараметров;
	Если Парсер.Элемент = Лексемы.Знач Тогда
		Если Подробно Тогда
			Ошибка(Парсер.Разбор, "Ключевое слово `Знач` пропущено");
		КонецЕсли;
		Дальше(Парсер);
	КонецЕсли;
	Сверить(Парсер, Лексемы.Идентификатор);
	Имя = Парсер.Литерал;
	Элемент = Дальше(Парсер);
	Если Элемент = Лексемы.Равно Тогда
		Элемент = Дальше(Парсер);
		Если ПростойЛитерал.Найти(Элемент) = Неопределено Тогда
			Ошибка(Парсер.Разбор, "Ожидается basic literal");
		КонецЕсли;
		Объект = Объект(ВидыОбъектов.Параметр, Имя, Элемент);
		ОбъявленияПараметров = ОбъявленияПараметров(Объект, Истина, ParseOperand(Парсер));
	Иначе
		Объект = Объект(ВидыОбъектов.Параметр, Имя, Неопределено);
		ОбъявленияПараметров = ОбъявленияПараметров(Объект);
	КонецЕсли;
	Парсер.Область.Объекты.Вставить(Имя, Объект);
	Возврат ОбъявленияПараметров;
КонецФункции // ПарситьОбъявленияПараметров()

Функция ParseStatements(Парсер)
	Перем Определения, Stmt;
	Определения = Новый Массив;
	Stmt = ParseStmt(Парсер);
	Пока Stmt <> Неопределено Цикл
		Определения.Добавить(Stmt);
		Stmt = ParseStmt(Парсер);
	КонецЦикла;
	Возврат Определения;
КонецФункции // ParseStatements()

Функция ParseStmt(Парсер)
	Перем Элемент;
	Элемент = SkipИгнорируемыеЛексемы(Парсер);
	Пока Элемент = Лексемы.ТочкаСЗапятой Цикл
		Дальше(Парсер);
		Элемент = SkipИгнорируемыеЛексемы(Парсер);
	КонецЦикла;
	Если Элемент = Лексемы.Идентификатор Тогда
		Возврат ParseAssignOrCallStmt(Парсер);
	ИначеЕсли Элемент = Лексемы.Если Тогда
		Возврат ParseIfStmt(Парсер);
	ИначеЕсли Элемент = Лексемы.Попытка Тогда
		Возврат ParseTryStmt(Парсер);
	ИначеЕсли Элемент = Лексемы.Пока Тогда
		Возврат ParseWhileStmt(Парсер);
	ИначеЕсли Элемент = Лексемы.Для Тогда
		Возврат ParseForStmt(Парсер);
	ИначеЕсли Элемент = Лексемы.Выбор Тогда
		Возврат ParseCaseStmt(Парсер);
	ИначеЕсли Элемент = Лексемы.Возврат Тогда
		Возврат ParseReturnStmt(Парсер);
	ИначеЕсли Элемент = Лексемы.Прервать Тогда
		Дальше(Парсер);
		Возврат BreakStmt();
	ИначеЕсли Элемент = Лексемы.Продолжить Тогда
		Дальше(Парсер);
		Возврат ContinueStmt();
	ИначеЕсли Элемент = Лексемы.ВызватьИсключение Тогда
		Возврат ParseRaiseStmt(Парсер);
	ИначеЕсли Элемент = Лексемы.Выполнить Тогда
		Возврат ParseExecuteStmt(Парсер);
	КонецЕсли;
	Возврат Неопределено;
КонецФункции // ParseStmt()

Функция ParseRaiseStmt(Парсер)
	Перем Элемент, Expr;
	Дальше(Парсер);
	Если НачальныеЛексемыВыражений.Найти(Парсер.Элемент) <> Неопределено Тогда
		Expr = ParseExpression(Парсер);
	КонецЕсли;
	Возврат RaiseStmt(Expr);
КонецФункции // ParseRaiseStmt()

Функция ParseExecuteStmt(Парсер)
	Перем Элемент, Expr;
	Дальше(Парсер);
	Сверить(Парсер, Лексемы.ОткрСкобкаОбычная);
	Элемент = Дальше(Парсер);
	Если Элемент = Лексемы.ЗакрСкобкаОбычная Тогда
		Expr = ПустойМассив;
	Иначе
		Expr = ParseExpression(Парсер);
	КонецЕсли;
	Сверить(Парсер, Лексемы.ЗакрСкобкаОбычная);
	Дальше(Парсер);
	Возврат ExecuteStmt(Expr);
КонецФункции // ParseExecuteStmt()

Функция ParseAssignOrCallStmt(Парсер)
	Перем Элемент, Лев, Прав;
	Лев = ParseDesignatorExprList(Парсер, Истина);
	Если Лев.Количество() = 1 И Лев[0].Вызов Тогда
		Возврат CallStmt(Лев);
	КонецЕсли;
	Элемент = Парсер.Элемент;
	Если Элемент = Лексемы.Равно Тогда
		Дальше(Парсер);
		Прав = ParseExprList(Парсер);
		Возврат AssignStmt(Лев, Прав);
	ИначеЕсли Элемент = Лексемы.Увеличить Тогда
		Дальше(Парсер);
		Прав = ParseExprList(Парсер);
		Возврат AddAssignStmt(Лев, Прав);
	КонецЕсли;
	Сверить(Парсер, Лексемы.Равно);
КонецФункции // ParseAssignOrCallStmt()

Функция ParseIfStmt(Парсер)
	Перем Элемент, Condition, ThenPart, ElsePart;
	Перем ElsIfPart, ElsIfCond, ElsIfThen;
	Дальше(Парсер);
	Condition = ParseExpression(Парсер);
	Сверить(Парсер, Лексемы.Тогда);
	Дальше(Парсер);
	ThenPart = ParseStatements(Парсер);
	Элемент = Парсер.Элемент;
	Если Элемент = Лексемы.ИначеЕсли Тогда
		ElsIfPart = Новый Массив;
		Пока Элемент = Лексемы.ИначеЕсли Цикл
			Дальше(Парсер);
			ElsIfCond = ParseExpression(Парсер);
			Сверить(Парсер, Лексемы.Тогда);
			Дальше(Парсер);
			ElsIfThen = ParseStatements(Парсер);
			ElsIfPart.Добавить(IfStmt(ElsIfCond, ElsIfThen));
			Элемент = Парсер.Элемент;
		КонецЦикла;
	КонецЕсли;
	Если Элемент = Лексемы.Иначе Тогда
		Дальше(Парсер);
		ElsePart = ParseStatements(Парсер);
	КонецЕсли;
	Сверить(Парсер, Лексемы.КонецЕсли);
	Дальше(Парсер);
	Возврат IfStmt(Condition, ThenPart, ElsIfPart, ElsePart);
КонецФункции // ParseIfStmt()

Функция ParseTryStmt(Парсер)
	Перем TryPart, ExceptPart;
	Дальше(Парсер);
	TryPart = ParseStatements(Парсер);
	Сверить(Парсер, Лексемы.Исключение);
	Дальше(Парсер);
	ExceptPart = ParseStatements(Парсер);
	Сверить(Парсер, Лексемы.КонецПопытки);
	Дальше(Парсер);
	Возврат TryStmt(TryPart, ExceptPart);
КонецФункции // ParseTryStmt()

Функция ParseCaseStmt(Парсер)
	Перем Элемент, Указатель, ElsePart;
	Перем WhenPart, WhenCond, WhenThen;
	Дальше(Парсер);
	Указатель = ПарситьУказатель(Парсер);
	Элемент = Парсер.Элемент;
	WhenPart = Новый Массив;
	Пока Элемент = Лексемы.Когда Цикл
		Дальше(Парсер);
		WhenCond = ParseExpression(Парсер);
		Сверить(Парсер, Лексемы.Тогда);
		Дальше(Парсер);
		WhenThen = ParseStatements(Парсер);
		WhenPart.Добавить(IfStmt(WhenCond, WhenThen));
		Элемент = Парсер.Элемент;
	КонецЦикла;
	Если Элемент = Лексемы.Иначе Тогда
		Дальше(Парсер);
		ElsePart = ParseStatements(Парсер);
	КонецЕсли;
	Сверить(Парсер, Лексемы.КонецВыбора);
	Дальше(Парсер);
	Возврат CaseStmt(Указатель, WhenPart, ElsePart);
КонецФункции // ParseCaseStmt()

Функция ParseWhileStmt(Парсер)
	Перем Condition, Определения;
	Дальше(Парсер);
	Condition = ParseExpression(Парсер);
	Сверить(Парсер, Лексемы.Цикл);
	Дальше(Парсер);
	Определения = ParseStatements(Парсер);
	Сверить(Парсер, Лексемы.КонецЦикла);
	Дальше(Парсер);
	Возврат WhileStmt(Condition, Определения)
КонецФункции // ParseWhileStmt()

Функция ParseForStmt(Парсер)
	Перем Указатель, Лев, Прав, Collection, Определения;
	Дальше(Парсер);
	Если Парсер.Элемент = Лексемы.Каждого Тогда
		Дальше(Парсер);
	КонецЕсли;
	Сверить(Парсер, Лексемы.Идентификатор);
	Указатель = ПарситьУказатель(Парсер, Истина);
	Если Указатель.Вызов Тогда
		Ошибка(Парсер.Разбор, "Ожидается переменная",, Истина);
	КонецЕсли;
	Если Парсер.Элемент = Лексемы.Равно Тогда
		Дальше(Парсер);
		Лев = ParseExpression(Парсер);
		Сверить(Парсер, Лексемы.По);
		Дальше(Парсер);
		Прав = ParseExpression(Парсер);
		Collection = RangeExpr(Лев, Прав);
	ИначеЕсли Парсер.Элемент = Лексемы.Из Тогда
		Дальше(Парсер);
		Collection = ParseExpression(Парсер);
	КонецЕсли;
	Сверить(Парсер, Лексемы.Цикл);
	Дальше(Парсер);
	Определения = ParseStatements(Парсер);
	Сверить(Парсер, Лексемы.КонецЦикла);
	Дальше(Парсер);
	Возврат ForStmt(Указатель, Collection, Определения);
КонецФункции // ParseForStmt()

Функция ParseVarDecls(Парсер)
	Перем Элемент, Объявления;
	Объявления = Новый Массив;
	Элемент = Парсер.Элемент;
	Пока Элемент = Лексемы.Перем Цикл
		Дальше(Парсер);
		Объявления.Добавить(ParseОбъявлениеПеременных(Парсер));
		Если Парсер.Элемент = Лексемы.ТочкаСЗапятой Тогда
			Дальше(Парсер);
		КонецЕсли;
		Элемент = Парсер.Элемент;
	КонецЦикла;
	Возврат Объявления;
КонецФункции // ParseVarDecls()

Функция ParseDecls(Парсер)
	Перем Элемент, Объявления;
	Объявления = Новый Массив;
	Элемент = Парсер.Элемент;
	Пока Элемент <> Лексемы.КонецФайла Цикл
		Если Элемент = Лексемы.Перем Тогда
			Дальше(Парсер);
			Объявления.Добавить(ParseОбъявлениеПеременных(Парсер));
			Если Парсер.Элемент = Лексемы.ТочкаСЗапятой Тогда
				Дальше(Парсер);
			КонецЕсли;
		ИначеЕсли Элемент = Лексемы.Функция Тогда
			Объявления.Добавить(ParseОбъявлениеФункции(Парсер));
		ИначеЕсли Элемент = Лексемы.Процедура Тогда
			Объявления.Добавить(ParseОбъявлениеПроцедуры(Парсер));
		Иначе
			Возврат Объявления;
		КонецЕсли;
		Элемент = Парсер.Элемент;
	КонецЦикла;
	Возврат Объявления;
КонецФункции // ParseDecls()

Функция ParseModule(Парсер) Экспорт
	Дальше(Парсер);
	Парсер.Модуль = Модуль(ParseDecls(Парсер), ParseStatements(Парсер));
	Если Подробно Тогда
		Для Каждого Элемент Из Парсер.Неизвестный Цикл
			Сообщить(СтрШаблон("Необъявленный идентификатор `%1`", Элемент.Key));
		КонецЦикла;
	КонецЕсли;
	Сверить(Парсер, Лексемы.КонецФайла);
КонецФункции // ParseModule()

#КонецОбласти // Парсер

#Область Auxiliary

Функция Значение(Элемент, Литерал)
	Если Элемент = Лексемы.Число Тогда
		Возврат Число(Литерал);
	ИначеЕсли Элемент = Лексемы.ДатаВремя Тогда
		Возврат КакДата(Литерал);
	ИначеЕсли Элемент = Лексемы.Строка Тогда
		Возврат Сред(Литерал, 2, СтрДлина(Литерал) - 2);
	ИначеЕсли Элемент = Лексемы.Истина Тогда
		Возврат Истина;
	ИначеЕсли Элемент = Лексемы.Ложь Тогда
		Возврат Ложь;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции // Значение()

Функция КакДата(знДата)
	Перем Список, Символ;
	Список = Новый Массив;
	Для Чис = 1 По СтрДлина(знДата) Цикл
		Символ = Сред(знДата, Чис, 1);
		Если ЭтоЦифра(Символ) Тогда
			Список.Добавить(Символ);
		КонецЕсли;
	КонецЦикла;
	Возврат Дата(СтрСоединить(Список));
КонецФункции // КакДата()

Процедура Сверить(Парсер, Элемент)
	Если Парсер.Элемент <> Элемент Тогда
		Ошибка(Парсер.Разбор, "Ожидается " + Элемент,, Истина);
	КонецЕсли;
КонецПроцедуры // Сверить()

Функция ЭлементСтроки(Литерал)
	Если Лев(Литерал, 1) = """" Тогда
		Если Прав(Литерал, 1) = """" Тогда
			Возврат Лексемы.Строка;
		Иначе
			Возврат Лексемы.НачалоСтроки;
		КонецЕсли;
	Иначе // |
		Если Прав(Литерал, 1) = """" Тогда
			Возврат Лексемы.КонецСтроки;
		Иначе
			Возврат Лексемы.СодержимоеСтроки;
		КонецЕсли;
	КонецЕсли;
КонецФункции // ЭлементСтроки()

Функция Проверить(Литерал)
	Перем Элемент;
	Если НЕ Дескрипторы.Свойство(Литерал, Элемент) Тогда
		Элемент = Лексемы.Идентификатор;
	КонецЕсли;
	Возврат Элемент;
КонецФункции // Проверить()

Функция ЭтоБуква(Символ)
	Возврат Символ <> "" И StrFind("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZабвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ", Символ) > 0;
КонецФункции // ЭтоБуква()

Функция ЭтоЦифра(Символ)
	Возврат "0" <= Символ И Символ <= "9";
КонецФункции // ЭтоЦифра()

Процедура Ошибка(Разбор, Сообщение, Столбец = Неопределено, Остановить = Ложь)
	Перем ТекстОшибки;
	ТекстОшибки = СтрШаблон("[ Ln: %1; Col: %2 ] %3",
		Разбор.Строка,
		?(Столбец = Неопределено, Разбор.Столбец - СтрДлина(Разбор.Литерал), Столбец),
		Сообщение
	);
	Если Остановить Тогда
		ВызватьИсключение ТекстОшибки;
	Иначе
		Сообщить(ТекстОшибки);
	КонецЕсли;
КонецПроцедуры // Ошибка()

#КонецОбласти // Auxiliary

#Область Backends

Функция Backend() Экспорт
	Перем Backend;

	Backend = Новый Структура(
		"Result," // array (Строка)
		"Indent" // Число
	,
	Новый Массив, -1);

	Возврат Backend;

КонецФункции // Backend()

Процедура Indent(Backend)
	Перем Result;
	Result = Backend.Result;
	Для Индекс = 1 По Backend.Indent Цикл
		Result.Добавить(Символы.Таб);
	КонецЦикла;
КонецПроцедуры // Indent()

#Область BSL

Процедура BSL_VisitModule(Backend, Модуль) Экспорт
	BSL_VisitDecls(Backend, Модуль.Объявления);
	BSL_VisitStatements(Backend, Модуль.Определения);
КонецПроцедуры // BSL_VisitModule()

Процедура BSL_VisitDecls(Backend, Объявления)
	Backend.Indent = Backend.Indent + 1;
	Для Каждого Decl Из Объявления Цикл
		BSL_VisitDecl(Backend, Decl);
	КонецЦикла;
	Backend.Indent = Backend.Indent - 1;
КонецПроцедуры // BSL_VisitDecls()

Процедура BSL_VisitStatements(Backend, Определения)
	Backend.Indent = Backend.Indent + 1;
	Для Каждого Stmt Из Определения Цикл
		BSL_VisitStmt(Backend, Stmt);
	КонецЦикла;
	Backend.Indent = Backend.Indent - 1;
	Indent(Backend);
КонецПроцедуры // BSL_VisitStatements()

Процедура BSL_VisitDecl(Backend, Decl)
	Перем Result, ТипУзла;
	Result = Backend.Result;
	ТипУзла = Decl.ТипУзла;
	Если ТипУзла = "ОбъявлениеПеременных" Тогда
		Indent(Backend);
		Result.Добавить("Перем ");
		BSL_VisitОбъявлениеПеременных(Backend, Decl.СписокПеременных);
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "ОбъявлениеФункции" ИЛИ ТипУзла = "ОбъявлениеПроцедуры" Тогда
		Result.Добавить(Символы.ПС);
		Backend.Indent = Backend.Indent + 1;
		Если ТипУзла = "ОбъявлениеФункции" Тогда
			Result.Добавить("Функция ");
		Иначе
			Result.Добавить("Процедура ");
		КонецЕсли;
		Result.Добавить(Decl.Объект.Имя);
		Result.Добавить("(");
		BSL_VisitОбъявлениеПеременных(Backend, Decl.Объект.ТипОбъекта.СписокПараметров);
		Result.Добавить(")");
		Result.Добавить(Символы.ПС);
		Для Каждого Stmt Из Decl.Объявления Цикл
			BSL_VisitDecl(Backend, Stmt);
		КонецЦикла;
		Для Каждого Stmt Из Decl.Определения Цикл
			BSL_VisitStmt(Backend, Stmt);
		КонецЦикла;
		Если ТипУзла = "ОбъявлениеФункции" Тогда
			Result.Добавить(СтрШаблон("КонецФункции // %1()", Decl.Объект.Имя));
		Иначе
			Result.Добавить(СтрШаблон("КонецПроцедуры // %1()", Decl.Объект.Имя));
		КонецЕсли;
		Result.Добавить(Символы.ПС);
		Backend.Indent = Backend.Indent - 1;
	КонецЕсли;
КонецПроцедуры // BSL_VisitDecl()

Процедура BSL_VisitОбъявлениеПеременных(Backend, ОбъявлениеПеременных)
	Перем Result, Buffer;
	Если ОбъявлениеПеременных <> Неопределено Тогда
		Result = Backend.Result;
		Buffer = Новый Массив;
		Для Каждого ОбъявленияПеременных Из ОбъявлениеПеременных Цикл
			Buffer.Добавить(ОбъявленияПеременных.Объект.Имя + ?(ОбъявленияПеременных.Свойство("Значение"), " = " + BSL_VisitExpr(ОбъявленияПеременных.Значение), ""));
		КонецЦикла;
		Если Buffer.Количество() > 0 Тогда
			Result.Добавить(СтрСоединить(Buffer, ", "));
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры // BSL_VisitОбъявлениеПеременных()

Процедура BSL_VisitStmt(Backend, Stmt)
	Перем Result, ТипУзла;
	Result = Backend.Result;
	ТипУзла = Stmt.ТипУзла;
	Indent(Backend);
	Если ТипУзла = "AssignStmt" Тогда
		Result.Добавить(BSL_VisitDesignatorExpr(Stmt.Лев[0]));
		Result.Добавить(" = ");
		Result.Добавить(BSL_VisitExprList(Stmt.Прав));
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "AddAssignStmt" Тогда
		Result.Добавить(BSL_VisitDesignatorExpr(Stmt.Лев[0]));
		Result.Добавить(" = ");
		Result.Добавить(BSL_VisitDesignatorExpr(Stmt.Лев[0]));
		Result.Добавить(" + ");
		Result.Добавить(BSL_VisitExprList(Stmt.Прав));
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "ReturnStmt" Тогда
		Result.Добавить("Возврат ");
		Если Stmt.Свойство("ExprList") Тогда
			Result.Добавить(BSL_VisitExprList(Stmt.ExprList));
		КонецЕсли;
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "BreakStmt" Тогда
		Result.Добавить("Прервать;");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "ContinueStmt" Тогда
		Result.Добавить("Продолжить;");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "RaiseStmt" Тогда
		Result.Добавить("ВызватьИсключение ");
		Если Stmt.Свойство("Expr") Тогда
			Result.Добавить(BSL_VisitExpr(Stmt.Expr));
		КонецЕсли;
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "ExecuteStmt" Тогда
		Result.Добавить("Выполнить(");
		Result.Добавить(BSL_VisitExpr(Stmt.Expr));
		Result.Добавить(");");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "CallStmt" Тогда
		Result.Добавить(BSL_VisitDesignatorExpr(Stmt.Указатель[0]));
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "IfStmt" Тогда
		Result.Добавить("Если ");
		BSL_VisitIfStmt(Backend, Stmt);
		Если Stmt.Свойство("ElsePart") Тогда
			Result.Добавить("Иначе");
			Result.Добавить(Символы.ПС);
			BSL_VisitStatements(Backend, Stmt.ElsePart);
		КонецЕсли;
		Result.Добавить("КонецЕсли");
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "WhileStmt" Тогда
		Result.Добавить("Пока ");
		Result.Добавить(BSL_VisitExpr(Stmt.Condition));
		Result.Добавить(" Цикл");
		Result.Добавить(Символы.ПС);
		BSL_VisitStatements(Backend, Stmt.Определения);
		Result.Добавить("КонецЦикла");
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "ForStmt" Тогда
		Result.Добавить("Для ");
		Если Stmt.Collection.ТипУзла = "RangeExpr" Тогда
			Result.Добавить(BSL_VisitDesignatorExpr(Stmt.Указатель));
			Result.Добавить(" = ");
			Result.Добавить(BSL_VisitExpr(Stmt.Collection));
		Иначе
			Result.Добавить("Каждого ");
			Result.Добавить(BSL_VisitDesignatorExpr(Stmt.Указатель));
			Result.Добавить(" Из ");
			Result.Добавить(BSL_VisitExpr(Stmt.Collection));
		КонецЕсли;
		Result.Добавить(" Цикл");
		Result.Добавить(Символы.ПС);
		BSL_VisitStatements(Backend, Stmt.Определения);
		Result.Добавить("КонецЦикла");
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	ИначеЕсли ТипУзла = "CaseStmt" Тогда
		Если Stmt.WhenPart.Количество() > 0 Тогда
			Result.Добавить("Если ");
			Result.Добавить(BSL_VisitDesignatorExpr(Stmt.Указатель));
			Result.Добавить(" = ");
			IfStmt = Stmt.WhenPart[0];
			BSL_VisitIfStmt(Backend, IfStmt);
			Для Индекс = 1 По Stmt.WhenPart.Количество() - 1 Цикл
				IfStmt = Stmt.WhenPart[Индекс];
				Result.Добавить("ИначеЕсли ");
				Result.Добавить(BSL_VisitDesignatorExpr(Stmt.Указатель));
				Result.Добавить(" = ");
				BSL_VisitIfStmt(Backend, IfStmt);
			КонецЦикла;
			Если Stmt.Свойство("ElsePart") Тогда
				Result.Добавить("Иначе");
				Result.Добавить(Символы.ПС);
				BSL_VisitStatements(Backend, Stmt.ElsePart);
			КонецЕсли;
			Result.Добавить("КонецЕсли");
			Result.Добавить(";");
			Result.Добавить(Символы.ПС);
		Иначе
			Result.Добавить(Символы.ПС);
			Backend.Indent = Backend.Indent - 1;
			Если Stmt.Свойство("ElsePart") Тогда
				BSL_VisitStatements(Backend, Stmt.ElsePart);
			КонецЕсли;
			Backend.Indent = Backend.Indent + 1;
			Result.Добавить(Символы.ПС);
		КонецЕсли;
	ИначеЕсли ТипУзла = "TryStmt" Тогда
		Result.Добавить("Попытка");
		Result.Добавить(Символы.ПС);
		BSL_VisitStatements(Backend, Stmt.TryPart);
		Result.Добавить("Исключение");
		Result.Добавить(Символы.ПС);
		BSL_VisitStatements(Backend, Stmt.ExceptPart);
		Result.Добавить("КонецПопытки");
		Result.Добавить(";");
		Result.Добавить(Символы.ПС);
	КонецЕсли;
КонецПроцедуры // BSL_VisitStmt()

Процедура BSL_VisitIfStmt(Backend, IfStmt)
	Перем Result;
	Result = Backend.Result;
	Result.Добавить(BSL_VisitExpr(IfStmt.Condition));
	Result.Добавить(" Тогда");
	Result.Добавить(Символы.ПС);
	BSL_VisitStatements(Backend, IfStmt.ThenPart);
	Если IfStmt.Свойство("ElsIfPart") Тогда
		Для Каждого Элемент Из IfStmt.ElsIfPart Цикл
			Result.Добавить("ИначеЕсли ");
			BSL_VisitIfStmt(Backend, Элемент);
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры // BSL_VisitIfStmt()

Функция BSL_VisitExprList(ExprList)
	Перем Buffer;
	Если ExprList <> Неопределено Тогда
		Buffer = Новый Массив;
		Для Каждого Expr Из ExprList Цикл
			Если Expr = Неопределено Тогда
				Buffer.Добавить("");
			Иначе
				Buffer.Добавить(BSL_VisitExpr(Expr));
			КонецЕсли;
		КонецЦикла;
		Возврат СтрСоединить(Buffer, ", ");
	КонецЕсли;
КонецФункции // BSL_VisitExprList()

Функция BSL_VisitExpr(Expr)
	Перем ТипУзла, BasicLitKind;
	ТипУзла = Expr.ТипУзла;
	Если ТипУзла = "ПростойЛитерал" Тогда
		BasicLitKind = Expr.Вид;
		Если BasicLitKind = Лексемы.Строка Тогда
			Возврат СтрШаблон("""%1""", StrReplace(Expr.Значение, Символы.ПС, """ """));
		ИначеЕсли BasicLitKind = Лексемы.Число Тогда
			Возврат Format(Expr.Значение, "NZ=0; NG=");
		ИначеЕсли BasicLitKind = Лексемы.ДатаВремя Тогда
			Возврат Format(Expr.Значение, "DF='""''yyyyMMdd'''");
		ИначеЕсли BasicLitKind = Лексемы.Истина ИЛИ BasicLitKind = Лексемы.Ложь Тогда
			Возврат Format(Expr.Значение, "BF=Ложь; BT=Истина");
		ИначеЕсли BasicLitKind = Лексемы.Неопределено Тогда
			Возврат "Неопределено";
		Иначе
			ВызватьИсключение "Неизвестный basic literal";
		КонецЕсли;
	ИначеЕсли ТипУзла = "Указатель" Тогда
		Возврат BSL_VisitDesignatorExpr(Expr);
	ИначеЕсли ТипУзла = "UnaryExpr" Тогда
		Возврат СтрШаблон("%1 %2", Операторы[Expr.Operator], BSL_VisitExpr(Expr.Operand));
	ИначеЕсли ТипУзла = "BinaryExpr" Тогда
		Возврат СтрШаблон("%1 %2 %3", BSL_VisitExpr(Expr.Лев), Операторы[Expr.Operator], BSL_VisitExpr(Expr.Прав));
	ИначеЕсли ТипУзла = "RangeExpr" Тогда
		Возврат СтрШаблон("%1 По %2", BSL_VisitExpr(Expr.Лев), BSL_VisitExpr(Expr.Прав));
	ИначеЕсли ТипУзла = "NewExpr" Тогда
		Если ТипЗнч(Expr.Конструктор) = Тип("Структура") Тогда
			Возврат СтрШаблон("Новый %1", BSL_VisitExpr(Expr.Конструктор));
		Иначе
			Возврат СтрШаблон("Новый(%1)", BSL_VisitExprList(Expr.Конструктор));
		КонецЕсли;
	ИначеЕсли ТипУзла = "TernaryExpr" Тогда
		Возврат СтрШаблон("?(%1, %2, %3)", BSL_VisitExpr(Expr.Condition), BSL_VisitExpr(Expr.ThenPart), BSL_VisitExpr(Expr.ElsePart));
	ИначеЕсли ТипУзла = "ParenExpr" Тогда
		Возврат СтрШаблон("(%1)", BSL_VisitExpr(Expr.Expr));
	КонецЕсли;
КонецФункции // BSL_VisitExpr()

Функция BSL_VisitDesignatorExpr(Указатель)
	Перем Buffer;
	Buffer = Новый Массив;
	Buffer.Добавить(Указатель.Объект.Имя);
	Если Указатель.Свойство("Разделители") Тогда
		Для Каждого Разделитель Из Указатель.Разделители Цикл
			Если Разделитель.Вид = "Идентификатор" Тогда
				Buffer.Добавить(".");
				Buffer.Добавить(Разделитель.Значение);
			ИначеЕсли Разделитель.Вид = "Индекс" Тогда
				Buffer.Добавить("[");
				Buffer.Добавить(BSL_VisitExprList(Разделитель.Значение));
				Buffer.Добавить("]");
			ИначеЕсли Разделитель.Вид = "Вызов" Тогда
				Buffer.Добавить("(");
				Buffer.Добавить(BSL_VisitExprList(Разделитель.Значение));
				Buffer.Добавить(")");
			Иначе
				ВызватьИсключение "Неизвестный Разделитель Вид";
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат СтрСоединить(Buffer);
КонецФункции // BSL_VisitDesignatorExpr()

#КонецОбласти // BSL

#КонецОбласти // Backends

Подробно = Истина;

Если АргументыКоманднойСтроки.Количество() Тогда

	FormOutput = "BSL";

	Start = CurrentUniversalDateInMilliseconds();

	FormSource = Новый ТекстовыйДокумент;
	FormSource.Прочитать(АргументыКоманднойСтроки[0], TextEncoding.UTF8);

	Если FormOutput = "Lexems" Тогда

		КонецФайла = Лексемы().КонецФайла;

		Разбор = Разбор(FormSource.GetText());
		Пока Разобрать(Разбор) <> КонецФайла Цикл
			Сообщить(СтрШаблон("%1: %2 -- `%3`", Разбор.Строка, Разбор.Элемент, Разбор.Литерал));
		КонецЦикла;

	ИначеЕсли FormOutput = "AST" Тогда

		Парсер = Парсер(FormSource.GetText());
		ParseModule(Парсер);
		Сообщить(Парсер.Модуль);
		// JSONWriter = Новый JSONWriter;
		// FileName = GetTempFileName(".json");
		// JSONWriter.OpenFile(FileName,,, Новый JSONWriterSettings(, Символы.Tab));
		// ЗаписатьJSON(JSONWriter, Парсер.Модуль);
		// JSONWriter.Close();
		// FormResult = Новый ТекстовыйДокумент(FileName, TextEncoding.UTF8);
		// FormResult.Read(FileName, TextEncoding.UTF8);

	ИначеЕсли FormOutput = "BSL" Тогда

		Backend = Backend();
		Парсер = Парсер(FormSource.GetText());
		ParseModule(Парсер);
		BSL_VisitModule(Backend, Парсер.Модуль);

		FormResult = Новый ТекстовыйДокумент;
		FormResult.SetText(СтрСоединить(Backend.Result));
		FormResult.Записать(АргументыКоманднойСтроки[1]);

	КонецЕсли;

	Сообщить((CurrentUniversalDateInMilliseconds() - Start) / 1000);

Иначе

	Сообщить("укажите имя файла для обработки и имя файла результата");

КонецЕсли;
