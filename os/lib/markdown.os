// Парсер Markdown
// Код источника здесь:
// https://github.com/kuntashov/markdown/blob/develop/src/markdown.os

Перем МассивОпредедений;
Перем ТипыБлоков, ТипыИнлайнов;

///////////////////////////////////////////////////////////////////////////////
/// ПУБЛИЧНЫЙ API
///////////////////////////////////////////////////////////////////////////////

Перем URLОбработаны Экспорт;
Перем РазметкаЭкранирована Экспорт;


Функция ИмяЗначение(Имя, Значение = "")
	Возврат Новый Структура("Имя, Значение", Имя, Значение);
КонецФункции


Функция Парсер_Свойства(Данные, оУзел) Экспорт
	Перем Свойства;

	Если НЕ оУзел.Свойство("Свойства", Свойства) Тогда // новый объект
		Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""));
		шСвойства = "
		|Текст
		|Док
		|Вид
		|";
		Данные.СоздатьСвойства(Свойства, шСвойства);
		оУзел.Вставить("Свойства", Свойства);
	КонецЕсли;
	Свойства.д.Док.Значение = Данные.Корень.Свойства.д.Файл.Значение;
	Свойства.д.Вид.Значение = "";

КонецФункции


Функция Парсер_Модель(Данные, Свойства, Изменения) Экспорт

	Если Свойства.д.Вид.Значение = "" ИЛИ Изменения.Получить(Свойства.д.Текст) = Истина Тогда
		// сформировать представление
		Если НЕ Свойства.д.Док.Значение = "" Тогда
			Свойства.д.Вид.Значение = ПреобразоватьФайл(Свойства.д.Док.Значение);
		Иначе
			Свойства.д.Вид.Значение	= Преобразовать(Свойства.д.Текст.Значение);
		КонецЕсли;
	КонецЕсли;

КонецФункции


Функция Версия() Экспорт

	Возврат "1.0";
КонецФункции


Функция ПреобразоватьФайл(Знач ИмяДанных) Экспорт

	МассивОпредедений = Новый Массив;

	Текст = Новый ТекстовыйДокумент;

	Папка = "doc";
	Если ИмяДанных = "useyourmind" Тогда
		ИмяДанных = "README";
		Папка = ".";
	КонецЕсли;

	Текст.Прочитать(ОбъединитьПути(ТекущийКаталог(), Папка, ИмяДанных + ".md"), "utf-8");

	ТекстHtml = СокрЛПРасш(ПреобразоватьПострочно(Текст), Символы.ПС);

	Возврат ТекстHtml;
КонецФункции

Функция Преобразовать(Знач ТекстMarkdown) Экспорт

	МассивОпредедений = Новый Массив;

	Текст = Новый ТекстовыйДокумент;
	Текст.УстановитьТекст(ТекстMarkdown);

	ТекстHtml = СокрЛПРасш(ПреобразоватьПострочно(Текст), Символы.ПС);

	Возврат ТекстHtml;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
/// РЕАЛИЗАЦИЯ
///////////////////////////////////////////////////////////////////////////////

Функция ПреобразоватьПострочно(ТекстДок)

	МассивБлоков = Новый Массив;

	ТекущийБлок = Неопределено;

	КоличествоСтрок = ТекстДок.КоличествоСтрок();
	Для НомерСтроки = 1 по КоличествоСтрок Цикл

		Стр = ТекстДок.ПолучитьСтроку(НомерСтроки);

		Если ПустаяСтрока(Стр) Тогда

			Если ТекущийБлок <> Неопределено Тогда
				ТекущийБлок.Вставить("interrupted", Истина);
			КонецЕсли;

			Продолжить;

		КонецЕсли;

		Если СтрНайти(Стр, Символы.Таб) > 0 Тогда

			Части = СтрРазделить(Стр, Символы.Таб);
			Стр = Части[0];

			Для Индекс=1 По Части.Количество() - 1 Цикл
				СколькоПробеловДополнить = 4 - СтрДлина(Стр) % 4;
				Стр = Стр + СтрПовторить(" ", СколькоПробеловДополнить);
				Стр = Стр + Части[Индекс];
			КонецЦикла;

		КонецЕсли;

		ДлинаОтступа = 0;
		Пока (ДлинаОтступа + 1 < СтрДлина(Стр) И Сред(Стр, ДлинаОтступа + 1, 1) = " ") Цикл
			ДлинаОтступа = ДлинаОтступа + 1;
		КонецЦикла;

		Текст = ?(ДлинаОтступа > 0, Сред(Стр, ДлинаОтступа + 1), Стр);

		СтруктураСтроки = Новый Структура("body,indent,text", Стр, ДлинаОтступа, Текст);

		Если ЕстьКлюч(ТекущийБлок, "continuable") Тогда

			Блок = ВызватьОбработчикБлока(ТекущийБлок.type, "Продолжение", СтруктураСтроки, ТекущийБлок);

			Если Блок <> Неопределено Тогда

				ТекущийБлок = Блок;
				Продолжить;

			ИначеЕсли ЭтоЗавершаемыйБлок(ТекущийБлок.type) Тогда

				ТекущийБлок = ВызватьОбработчикБлока(ТекущийБлок.type, "Завершение", ТекущийБлок);

			КонецЕсли;

		КонецЕсли;

		Маркер = Сред(Текст, 1, 1);

		ВремТипыБлоков = НемаркерованныеТипыБлоков();
		Если ТипыБлоков[Маркер] <> Неопределено Тогда
			Для каждого ТипБлока из ТипыБлоков[Маркер] Цикл
				ВремТипыБлоков.Добавить(ТипБлока);
			КонецЦикла;
		КонецЕсли;

		ПродолжитьСоСледующейСтрокой = Ложь;

		Для каждого ТипБлока из ВремТипыБлоков Цикл

			Блок =  ВызватьОбработчикБлока(ТипБлока, "", СтруктураСтроки, ТекущийБлок);

			Если Блок <> Неопределено Тогда
				Сообщить("Тип блока: " + ТипБлока);
				Блок.Вставить("type", ТипБлока);
				Если НЕ Блок.Свойство("identified") Тогда
					МассивБлоков.Добавить(ТекущийБлок);
					Блок.Вставить("identified", Истина);
				КонецЕсли;

				Если ЭтоПродолжаемыйБлок(ТипБлока) Тогда
					Блок.Вставить("continuable", Истина);
				КонецЕсли;

				ТекущийБлок = Блок;

				ПродолжитьСоСледующейСтрокой = Истина;
				Прервать;

			КонецЕсли;

		КонецЦикла;

		Если ПродолжитьСоСледующейСтрокой Тогда
			Продолжить;
		КонецЕсли;

		Если ТекущийБлок <> Неопределено И НЕ ТекущийБлок.Свойство("type") И НЕ ТекущийБлок.Свойство("interrupted") Тогда
			ТекущийБлок.element.text = ТекущийБлок.element.text + Символы.ПС + Текст;
		Иначе
			МассивБлоков.Добавить(ТекущийБлок);
			ТекущийБлок = ОбработатьПараграф(СтруктураСтроки);
			ТекущийБлок.Вставить("identified", Истина);
		КонецЕсли;

	КонецЦикла;

	Если ТекущийБлок.Свойство("continuable") И ЭтоЗавершаемыйБлок(ТекущийБлок.type) Тогда
		ТекущийБлок = ВызватьОбработчикБлока(ТекущийБлок.type, "Завершение", ТекущийБлок);
	КонецЕсли;

	МассивБлоков.Добавить(ТекущийБлок);
	МассивБлоков.Удалить(0);

	Разметка = "";

	Для каждого Блок из МассивБлоков Цикл
		Если Блок.Свойство("hidden") Тогда
			Продолжить;
		КонецЕсли;
		Разметка = Разметка + Символы.ПС;
		Разметка = Разметка + ?(Блок.Свойство("markup"), Блок["markup"], ОбработатьElement(Блок["element"]));
	КонецЦикла;

	Размерка = Разметка + Символы.ПС;

	Возврат Разметка;
КонецФункции


Функция ВыполнитьОбработчикТекста(ИмяОбработчика, Текст)

	Если ИмяОбработчика = "element" Тогда
		Возврат ОбработатьElement(Текст);
	ИначеЕсли ИмяОбработчика = "elements" Тогда
		Возврат ОбработатьElements(Текст);
	ИначеЕсли ИмяОбработчика = "line" Тогда
		Возврат ОбработатьLine(Текст);
	ИначеЕсли ИмяОбработчика = "lines" Тогда

	ИначеЕсли ИмяОбработчика = "li" Тогда
		Возврат ОбработатьLine(Текст);
	Иначе
		ВызватьИсключение "Не известный обработчик: " + ИмяОбработчика;

	КонецЕсли;

	ВызватьИсключение "Обработчик " + ИмяОбработчика + " не реализован!";
КонецФункции // ВыполнитьОбработчикТекста()

Функция ОбработатьПараграф(СтруктураСтроки)

	Блок = Новый Структура("element");
	Блок.element = Новый Структура("name,text,handler", "p", СтруктураСтроки.text, "line");

	Возврат Блок;
КонецФункции

Функция ОбработатьElement(Элемент)

	Перем Атрибуты, Текст, ИмяОбработчика;

	Разметка = ДобавитьКСтроке("<", Элемент.name);

	Если Элемент.Свойство("attributes", Атрибуты) Тогда
		Для каждого Атрибут из Атрибуты Цикл
			Если НЕ ПустаяСтрока(Атрибут.Значение) Тогда
				ДобавитьКСтроке(Разметка, " " + Атрибут.Ключ + "=""" + Атрибут.Значение + """");
			КонецЕсли;
		КонецЦикла
	КонецЕсли;

	Если Элемент.Свойство("text", Текст) Тогда
		ДобавитьКСтроке(Разметка, ">");
		Если Элемент.Свойство("handler", ИмяОбработчика) Тогда
			ДобавитьКСтроке(Разметка, ВыполнитьОбработчикТекста(ИмяОбработчика, Элемент.text));
		Иначе
			ДобавитьКСтроке(Разметка, Элемент.text);
		КонецЕсли;
		ДобавитьКСтроке(Разметка, "</" + Элемент.name + ">");
	Иначе
		Разметка = Разметка + " />";
	КонецЕсли;

	Возврат Разметка;
КонецФункции

Функция ОбработатьElements(МассивЭлементов)
	Разметка = "";

	Для каждого Элемент из МассивЭлементов Цикл
		ДобавитьКСтроке(Разметка, Символы.ПС + ОбработатьElement(Элемент));
	КонецЦикла;

	ДобавитьКСтроке(Разметка, Символы.ПС);

	Возврат Разметка;
КонецФункции // ОбработатьElements(МассивЭлементов)

Функция ОбработатьLine(Знач Текст)

	Разметка = "";

	Для каждого Инлайн из ТипыИнлайнов Цикл

		Пока Истина Цикл // если несколько инлайнов одного типа

			Маркер = Инлайн.Ключ;

			ПозМаркера = Найти(Текст, Маркер);
			Если ПозМаркера = 0 Тогда
				Прервать;
			КонецЕсли;

			Подстрока = Сред(Текст, ПозМаркера);
			СтруктураПодстроки = Новый Структура("text,context", Подстрока, Текст);

			ПерейтиКСледующемуИнлайну = Ложь;

			Для каждого ТипИнлайна из Инлайн.Значение Цикл
				Сообщить("Тип инлайна: " + ТипИнлайна);
				СтруктураИнлайна = ВызватьОбработчикИнлайна(ТипИнлайна, СтруктураПодстроки);

				Если СтруктураИнлайна = Неопределено Тогда
					Продолжить;
				КонецЕсли;

				// Проверяем, что инлайн соответствует нашему маркеру.
				Если СтруктураИнлайна.Свойство("position") И СтруктураИнлайна.position > ПозМаркера Тогда
					Продолжить;
				КонецЕсли;

				// Запоминаем позицию инлайна по умолчанию.
				Если НЕ СтруктураИнлайна.Свойство("position") Тогда
					СтруктураИнлайна.Вставить("position", ПозМаркера);
				КонецЕсли;

				Если СтруктураИнлайна.position > 1 Тогда
					// Текст перед инлайном.
					ТекстБезРазметки = Лев(Текст, СтруктураИнлайна.position - 1);
					ДобавитьКСтроке(Разметка, ОбработатьТекстБезРазметки(ТекстБезРазметки));
				КонецЕсли;

				Если СтруктураИнлайна.Свойство("markup") Тогда
					ДобавитьКСтроке(Разметка, СтруктураИнлайна.markup);
				Иначе
					ДобавитьКСтроке(Разметка, ОбработатьElement(СтруктураИнлайна.element));
				КонецЕсли;

				Если СтруктураИнлайна.position + СтруктураИнлайна.extent < СтрДлина(Текст) Тогда
					// Обработанный текст удаляем и продолжаем с оставшейся частью.
					Текст = Сред(Текст, СтруктураИнлайна.position + СтруктураИнлайна.extent);
				Иначе
					Текст = "";
				КонецЕсли;

				ПерейтиКСледующемуИнлайну = Истина;
				Прервать;

			КонецЦикла;

			Если ПерейтиКСледующемуИнлайну Тогда
				Продолжить;
			КонецЕсли;

			// Маркер от другого инлайна.
			ТекстБезРазметки = Лев(Текст, ПозМаркера + 1);
			ДобавитьКСтроке(Разметка, ОбработатьТекстБезРазметки(ТекстБезРазметки));

			Текст = Сред(Текст, ПозМаркера + 1);

		КонецЦикла;

	КонецЦикла;

	ДобавитьКСтроке(Разметка, ОбработатьТекстБезРазметки(Текст));

	Возврат Разметка;
КонецФункции // ОбработатьElements()

Функция ОбработатьТекстБезРазметки(Знач Текст)
	// TODO: нужна полная реализация
	Текст = СтрЗаменить(Текст, Символы.ПС, "<br/>" + Символы.ПС);
	Возврат Текст;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
/// ОБРАБОТЧИКИ БЛОКОВ
///////////////////////////////////////////////////////////////////////////////

Функция ВызватьОбработчикБлока(ТипБлока, ТипОбработчика, Аргумент1=Неопределено, Аргумент2=Неопределено)

	Если ТипБлока = "Header" Тогда

		Возврат БлокHeader(Аргумент1);

	ИначеЕсли ТипБлока = "Code" Тогда

		Если ТипОбработчика = "" Тогда
			Возврат БлокCode(Аргумент1, Аргумент2);
		ИначеЕсли ТипОбработчика = "Продолжение" Тогда
			Возврат БлокCodeПродолжение(Аргумент1, Аргумент2);
		ИначеЕсли ТипОбработчика = "Завершение" Тогда
			Возврат БлокCodeЗавершение(Аргумент1);
		Иначе
			ВызватьИсключение "Для типа блока " + ТипБлока + " вызывается неизвестный тип обработчика " + ТипОбработчика;
		КонецЕсли;

	ИначеЕсли ТипБлока = "Rule" Тогда
		Возврат БлокRule(Аргумент1);

	ИначеЕсли ТипБлока = "List" Тогда
		Если ТипОбработчика = "" Тогда
			Возврат БлокList(Аргумент1);
		ИначеЕсли ТипОбработчика = "Продолжение" Тогда
			Возврат БлокListПродолжение(Аргумент1, Аргумент2);
		Иначе
			ВызватьИсключение "Для типа блока " + ТипБлока + " вызывается неизвестный тип обработчика " + ТипОбработчика;
		КонецЕсли;

	ИначеЕсли ТипБлока = "SetextHeader" Тогда
		Возврат БлокSetextHeader(Аргумент1);

	ИначеЕсли ТипБлока = "Table" Тогда

		Если ТипОбработчика = "" Тогда
			Возврат БлокTable(Аргумент1, Аргумент2);
		ИначеЕсли ТипОбработчика = "Продолжение" Тогда
			Возврат БлокTableПродолжение(Аргумент1, Аргумент2);
		Иначе
			ВызватьИсключение "Для типа блока " + ТипБлока + " вызывается неизвестный тип обработчика " + ТипОбработчика;
		КонецЕсли;


	ИначеЕсли ТипБлока = "Comment" Тогда

		Если ТипОбработчика = "" Тогда
			Возврат БлокComment(Аргумент1);
		ИначеЕсли ТипОбработчика = "Продолжение" Тогда
			Возврат БлокCommentПродолжение(Аргумент1, Аргумент2);
		Иначе
			ВызватьИсключение "Для типа блока " + ТипБлока + " вызывается неизвестный тип обработчика " + ТипОбработчика;
		КонецЕсли;

	ИначеЕсли ТипБлока = "Markup" Тогда

		Если ТипОбработчика = "" Тогда
			Возврат БлокMarkup(Аргумент1);
		ИначеЕсли ТипОбработчика = "Продолжение" Тогда
			Возврат БлокMarkupПродолжение(Аргумент1, Аргумент2);
		Иначе
			ВызватьИсключение "Для типа блока " + ТипБлока + " вызывается неизвестный тип обработчика " + ТипОбработчика;
		КонецЕсли;

	ИначеЕсли ТипБлока = "Quote" Тогда
	ИначеЕсли ТипБлока = "Reference" Тогда
	ИначеЕсли ТипБлока = "FencedCode" Тогда

	Иначе
		Возврат "Неизвестный тип блока: " + ТипБлока;
	КонецЕсли;

	Сообщить("Обработчик для типа блока " + ТипБлока + " не реализован");
	Возврат Неопределено;

КонецФункции

Функция БлокCode(СтруктураСтроки, Блок=Неопределено)

	Если Блок <> Неопределено И НЕ Блок.Свойство("type") И НЕ Блок.Свойство("interrupted") Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если СтруктураСтроки["indent"] >= 4 Тогда

		Текст = Сред(СтруктураСтроки["body"], 4);

		Элемент = Новый Структура;
		Элемент.Вставить("name", "pre");
		Элемент.Вставить("handler", "element");
		Элемент.Вставить("text", Новый Структура("name,text","code", Текст));

		Блок = Новый Структура("element", Элемент);

		Возврат Блок;

	КонецЕсли;

	Возврат Неопределено;
КонецФункции

Функция БлокCodeПродолжение(СтруктураСтроки, Блок)

	Если СтруктураСтроки["indent"] >= 4 Тогда

		Если Блок.Свойство("interrupted") Тогда

			ДобавитьКСтроке(Блок["element"]["text"]["text"], Символы.ПС);
			Блок.Удалить("interrupted");

		КонецЕсли;

		ДобавитьКСтроке(Блок["element"]["text"]["text"], Символы.ПС);

		Текст = Сред(СтруктураСтроки["body"], 4);

		ДобавитьКСтроке(Блок["element"]["text"]["text"], Текст);

		Возврат Блок;

	КонецЕсли;

	Возврат Неопределено;
КонецФункции

Функция БлокCodeЗавершение(Блок)

	Текст = ПреобразоватьСпецСимволыHTML(Блок["element"]["text"]["text"], Истина);

	Блок["element"]["text"]["text"] = Текст;

	Возврат Блок;
КонецФункции

Функция БлокComment(СтруктураСтроки)

	Если РазметкаЭкранирована = Истина Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если Сред(СтруктураСтроки.text, 2, 3) = "!--" Тогда

		Блок = Новый Структура("markup", СтруктураСтроки["body"]);

		Если Прав(СтруктураСтроки["text"], 3) = "-->" Тогда
			Блок.Вставить("closed", Истина);
		КонецЕсли;

		Возврат Блок;

	КонецЕсли;

	Возврат Неопределено;
КонецФункции

Функция БлокCommentПродолжение(СтруктураСтроки, Блок)

	Если Блок.Свойство("closed") Тогда
		Возврат Неопределено;
	КонецЕсли;

	ДобавитьКСтроке(Блок["markup"], Символы.ПС + СтруктураСтроки["text"]);

	Если Прав(СтруктураСтроки["text"], 3) = "-->" Тогда
		Блок.Вставить("closed", Истина);
	КонецЕсли;

	Возврат Блок;
КонецФункции // БлокCommentПродолжение(СтруктураСтроки, Блок)

Функция БлокFencedCode(СтруктураСтроки)

	ИдентификаторЯзыка = ПолучитьИдентификаторЯзыка(СтруктураСтроки["text"]);
	Если ИдентификаторЯзыка <> Неопределено Тогда

		Элемент = Новый Структура("name,text", "code", "");
		Если НЕ ПустаяСтрока(ИдентификаторЯзыка) Тогда
			Класс = "language-" + ИдентификаторЯзыка;
			Элемент.Вставить("attributes", Новый Структура("class", Класс));
		КонецЕсли;

		Блок = Новый Структура;
		Блок.Вставить("char", "`");
		Блок.Вставить("element", Новый Структура("name,handler,text", "pre", "element", Элемент));

		Возврат Блок;

	КонецЕсли;

	Возврат Неопределено;
КонецФункции // БлокFencedCode()

Функция БлокFencedCodeПродолжение(СтруктураСтроки, Блок)

	Если Блок.Свойство("complete") Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если Блок.Свойство("interrupted") Тогда

		ДобавитьКСтроке(Блок["element"]["text"]["text"], Символы.ПС);
		Блок.Удалить("interrupted");

	КонецЕсли;

	Стр = СокрЛП(СтруктураСтроки["text"]);
	Если Лев(Стр, 3) = "`" И ПустаяСтрока(СтрЗаменить(Стр, "`", "")) Тогда

		Блок["element"]["text"]["text"] = Сред(Блок["element"]["text"]["text"], 2);
		Блок.Вставить("complete", Истина);
		Возврат Блок;

	КонецЕсли;

	ДобавитьКСтроке(Блок["element"]["text"]["text"], Символы.ПС + СтруктураСтроки["body"]);

	Возврат Блок;
КонецФункции

Функция БлокFencedCodeЗавершение(Блок)

	Текст = ПреобразоватьСпецСимволыHTML(Блок["element"]["text"]["text"], Истина);
	Блок["element"]["text"]["text"] = Текст;

	Возврат Блок;
КонецФункции

Функция БлокHeader(СтруктураСтроки)

	Текст = СтруктураСтроки["text"];

	ДлинаСтроки = СтрДлина(Текст);

	Если ДлинаСтроки > 1 Тогда

		Уровень = 1;
		Пока Уровень + 1 < ДлинаСтроки И Сред(Текст, Уровень + 1, 1) = "#" Цикл
			Уровень = Уровень + 1;
		КонецЦикла;

		Если Уровень > 6 Тогда
			Возврат Неопределено;
		КонецЕсли;

		Текст = СокрЛПРасш(Текст, "# ");

		Блок = Новый Структура;
		Блок.Вставить("element", Новый Структура(
			"name,handler,text",
			"h" + Мин(6, Уровень),
			"line",
			Текст
		));

		Возврат Блок;

	КонецЕсли;

	Возврат Неопределено;
КонецФункции // БлокHeader(СтруктураСтроки)

Функция БлокList(СтруктураСтроки)

	//СтруктураСтроки = Новый Структура("text", "11. тест");

	ЧастиСтроки = СтрРазделить(СтруктураСтроки.text, " ");
	Если ЧастиСтроки.Количество() > 1 Тогда

		НачалоСписка = Лев(ЧастиСтроки[0], 1);
		Имя = ?(Найти("*+-", НачалоСписка) > 0, "ul", "ol");

		Блок = Новый Структура;
		Блок.Вставить("indent", СтруктураСтроки.indent);
		Блок.Вставить("pattern", ""); //FIXME!!! 'pattern' => $pattern,
		Блок.Вставить("element", Новый Структура("name,handler", Имя, "elements"));


		Если Имя = "ol" Тогда

			ПозТочки = Найти(ЧастиСтроки[0], ".");
			Если ПозТочки < 2 Тогда
				Возврат Неопределено;
			КонецЕсли;

			Попытка
				НомерПунктаСписка = Число(Лев(ЧастиСтроки[0], ПозТочки - 1));
			Исключение
				Возврат Неопределено;
			КонецПопытки;

			Если НомерПунктаСписка <> 1 Тогда
				Блок.element.Вставить("attributes", Новый Структура("start", НачалоСписка));
			КонецЕсли;

		КонецЕсли;

		ТекстПунктаСписка = Сред(СтруктураСтроки.text, СтрДлина(ЧастиСтроки[0]) + 2);

		Блок.Вставить("li", Новый Структура("name,handler,text", "li", "li", ТекстПунктаСписка));
		Блок.element.Вставить("text", Новый Массив);
		Блок.element.text.Добавить(Блок.li);

		Возврат Блок;

	КонецЕсли;

	Возврат Неопределено;
КонецФункции

Функция БлокListПродолжение(СтруктураСтроки, Блок)

	Если Блок.Свойство("complete") Тогда
		Возврат Неопределено;
	КонецЕсли;

	Маркер = Сред(СтруктураСтроки.text, 1, 1);
	Если НЕ Найти("*+-", Маркер) Тогда
		//Блок.Вставить("interrupted");
		Возврат Неопределено;
	КонецЕсли;

	Если Блок["indent"] = СтруктураСтроки.indent Тогда

		ЧастиСтроки = СтрРазделить(СтруктураСтроки.text, " ");
		Если ЧастиСтроки.Количество() > 1 Тогда

			Если Блок.Свойство("interrupted") Тогда
				Блок.Удалить("interrupted");
			КонецЕсли;

			Блок.Удалить("li");

			ТекстПунктаСписка = Сред(СтруктураСтроки.text, СтрДлина(ЧастиСтроки[0]) + 2);

			Блок.Вставить("li", Новый Структура("name,handler,text", "li", "li", ТекстПунктаСписка));
			Блок.element.text.Добавить(Блок.li);

			Возврат Блок;

		КонецЕсли;

	КонецЕсли;

КонецФункции

Функция БлокTable(СтруктураСтроки, Блок=Неопределено)

	Если Блок = Неопределено ИЛИ Блок.Свойство("type") ИЛИ Блок.Свойство("interrupted") Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если Найти(Блок.element.text, "|") > 0 И СокрПРасш(СтруктураСтроки.text, " -:|") = "" Тогда

		МассивВыравниваний = Новый Массив;

		Разделитель = СокрЛПРасш(СокрЛПРасш(СтруктураСтроки.text), "|");

		ЗначенияЯчеек = СтрРазделить(Разделитель, "|");
		Для каждого ЗначениеЯчейки из ЗначенияЯчеек Цикл
			ЗначениеЯчейки = СокрЛПРасш(ЗначениеЯчейки);
			Если ЗначениеЯчейки = "" Тогда
				Продолжить;
			КонецЕсли;
			Выравнивание = Неопределено;
			Если Лев(ЗначениеЯчейки, 1) = ":" Тогда
				Выравнивание = "left";
			КонецЕсли;
			Если Прав(ЗначениеЯчейки, 1) = ":" Тогда
				Выравнивание = ?(Выравнивание = "left", "center", "right");
			КонецЕсли;
			МассивВыравниваний.Добавить(Выравнивание);
		КонецЦикла;

		ЭлементыЗаголовка = Новый Массив;
		Заголовок = СокрЛПРасш(СокрЛПРасш(Блок.element.text), "|");

		ЯчейкиЗаголовка = СтрРазделить(Заголовок, "|");
		Для Индекс=0 По ЯчейкиЗаголовка.ВГраница() Цикл
			ЯчейкаЗаголовка = СокрЛПРасш(ЯчейкиЗаголовка[Индекс]);

			ЭлементЗаголовка = Новый Структура("name,text,handler", "th", ЯчейкаЗаголовка, "line");

			Если Индекс < МассивВыравниваний.Количество() И МассивВыравниваний[Индекс] <> Неопределено Тогда
				Выравнивание = МассивВыравниваний[Индекс];
				ЭлементЗаголовка.Вставить("attributes", Новый Структура("style", "text-align: " + Выравнивание + ";"));
			КонецЕсли;

			ЭлементыЗаголовка.Добавить(ЭлементЗаголовка);

		КонецЦикла;

		Блок = Новый Структура;
		Блок.Вставить("alignments", МассивВыравниваний);
		Блок.Вставить("identified", Истина);
		Блок.Вставить("element", Новый Структура("name,handler", "table", "elements"));

		Блок.element.Вставить("text", Новый Массив);
		Блок.element.text.Добавить(Новый Структура("name,handler,text", "thead", "elements", Новый Массив));

		Блок.element.text.Добавить(Новый Структура("name,handler,text", "tbody", "elements", Новый Массив));

		Блок.element.text[0].text.Добавить(Новый Структура("name,handler,text", "tr", "elements", ЭлементыЗаголовка));

		Возврат Блок;

	КонецЕсли;

	Возврат Неопределено;
КонецФункции

Функция БлокTableПродолжение(СтруктураСтроки, Блок)

	Если Блок.Свойство("interrupted") Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если Найти(СтруктураСтроки.text, "|") > 0 Тогда

		Элементы = Новый Массив;
		Стр = СокрЛПРасш(СокрЛПРасш(СтруктураСтроки.text), "|");

		Ячейки = СтрРазделить(Стр, "|");
		Для Индекс=0 по Ячейки.ВГраница() Цикл

			ЗначениеЯчейки = СокрЛПРасш(Ячейки[Индекс]);
			Элемент = Новый Структура("name,handler,text", "td", "line", ЗначениеЯчейки);

			Если Индекс < Блок.alignments.Количество() И Блок.alignments[Индекс] <> Неопределено Тогда
				Элемент.Вставить("attributes", Новый Структура("style", "text-align: " + Блок.alignments[Индекс] + ";"));
			КонецЕсли;

			Элементы.Добавить(Элемент);

		КонецЦикла;

		Элемент = Новый Структура("name,handler,text", "tr", "elements", Элементы);
		Блок.element.text[1].text.Добавить(Элемент);

		Возврат Блок;

	КонецЕсли;

	Возврат Неопределено;
КонецФункции // БлокTableПродолжение()

Функция БлокRule(СтруктураСтроки)

	Маркер = Лев(СтруктураСтроки.text, 1);

	// Если строка состоит только из подряд идущих символов "-" или "="
	Если СокрЛПРасш(СтруктураСтроки.text, " " + Маркер) = "" Тогда
		Блок = Новый Структура("element", Новый Структура("name", "hr"));
		Возврат Блок;
	КонецЕсли;

	Возврат Неопределено;
КонецФункции

Функция БлокSetextHeader(СтруктураСтроки, Блок=Неопределено)

	Если Блок = Неопределено ИЛИ Блок.Свойство("type") или Блок.Свойство("interrupted") Тогда
		Возврат Неопределено;
	КонецЕсли;

	Маркер = Лев(СтруктураСтроки.text, 1);

	Если СокрПРасш(СтруктураСтроки.text, Маркер) = "" Тогда
		Блок.element.Вставить("name", ?(Маркер = "=", "h1", "h2"));
		Возврат Блок;
	КонецЕсли;

	Возврат Неопределено;
КонецФункции // БлокSetextHeader()

Функция БлокMarkup(СтруктураСтроки)

	Возврат Неопределено;

	Если РазметкаЭкранирована = Истина Тогда
		Возврат Неопределено;
	КонецЕсли;

	// TODO

	Возврат Неопределено;
КонецФункции

Функция БлокMarkupПродолжение(СтруктураСтроки, Блок)

	// TODO

	Возврат Неопределено;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
/// ОБРАБОТЧИКИ ИНЛАЙНОВ
///////////////////////////////////////////////////////////////////////////////

Функция ВызватьОбработчикИнлайна(ТипИнлайна, СтруктураПодстроки)

	Если      ТипИнлайна = "Image" Тогда
	ИначеЕсли ТипИнлайна = "Code" Тогда
	ИначеЕсли ТипИнлайна = "SpecialCharacter" Тогда
		Возврат ИнлайнSpecialCharacter(СтруктураПодстроки);
	ИначеЕсли ТипИнлайна = "Emphasis" Тогда
		Возврат ИнлайнEmphasis(СтруктураПодстроки);
	ИначеЕсли ТипИнлайна = "Link" Тогда
		Возврат ИнлайнLink(СтруктураПодстроки);
	ИначеЕсли ТипИнлайна = "Url" Тогда
		Возврат ИнлайнUrl(СтруктураПодстроки);
	ИначеЕсли ТипИнлайна = "UrlTag" Тогда
		Возврат ИнлайнUrlTag(СтруктураПодстроки);
	ИначеЕсли ТипИнлайна = "EmailTag" Тогда
	ИначеЕсли ТипИнлайна = "Markup" Тогда
	ИначеЕсли ТипИнлайна = "Strikethrough" Тогда
	ИначеЕсли ТипИнлайна = "EscapeSequence" Тогда
	Иначе
		ВызватьИсключение "Неизвестный инлайн: " + ТипИнлайна;
	КонецЕсли;

	Сообщить("Обработчик инлайна " + ТипИнлайна + " не реализован");
	Возврат Неопределено;
КонецФункции

Функция ИнлайнSpecialCharacter(СтруктураПодстроки)

	Если Лев(СтруктураПодстроки.text, 1) = "&" И НЕ ЭтоЗакодированныйСимвол(СтруктураПодстроки.text) Тогда
		Возврат Новый Структура("markup,extent", "&amp;", 1);
	КонецЕсли;

	СоответствиеСпецсимволов = Новый Соответствие;
	СоответствиеСпецсимволов.Вставить("<", "lt");
	СоответствиеСпецсимволов.Вставить(">", "gt");
	СоответствиеСпецсимволов.Вставить("""", "quot");

	ИмяСпецсимвола = СоответствиеСпецсимволов[Лев(СтруктураПодстроки.text, 1)];
	Если ИмяСпецсимвола <> Неопределено Тогда
		Возврат Новый Структура("markup,extent", "&" + ИмяСпецсимвола + ";", 1);
	КонецЕсли;

	Возврат Неопределено;
КонецФункции

Функция ИнлайнEmphasis(СтруктураПодстроки)

	Перем СтрСодержимое;

	Если СтрДлина(СтруктураПодстроки.text) < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;

	Маркер = Лев(СтруктураПодстроки.text, 1);
	// Маркер сдвоенный (сильный акцент/strong)?
	Если Сред(СтруктураПодстроки.text, 2, 1) = Маркер Тогда
		Маркер = Маркер + Маркер;
	КонецЕсли;

	Если НЕ СодержитАкцент(СтруктураПодстроки.text, Маркер, СтрСодержимое) Тогда
		Возврат Неопределено;
	КонецЕсли;

	ТэгАкцента = ?(СтрДлина(Маркер) = 2, "strong", "em");

	Инлайн = Новый Структура;
	Инлайн.Вставить("extent", СтрДлина(СтрСодержимое) + 2 * СтрДлина(Маркер));
	Инлайн.Вставить("element", Новый Структура(
		"name,handler,text",
		ТэгАкцента,
		"line",
		СтрСодержимое
	));

	Возврат Инлайн;
КонецФункции

Функция СодержитАкцент(Знач Текст, Знач Маркер, СтрСодержимое)

	ДлинаМаркера = СтрДлина(Маркер);

	Если Лев(Текст, ДлинаМаркера) <> Маркер Тогда
		Возврат Ложь;
	КонецЕсли;

	Текст = Сред(Текст, ДлинаМаркера + 1);
	ПозКонца = Найти(Текст, Маркер);
	Если ПозКонца = 0 Тогда
		Возврат Ложь;
	КонецЕсли;

	СтрСодержимое = Лев(Текст, ПозКонца - 1);

	Возврат Истина;
КонецФункции // СодержитАкцент()

Функция ИнлайнUrlTag(СтруктураПодстроки)

	// <http://example.com>

	ПозКонца = Найти(СтруктураПодстроки.text, ">");
	Если ПозКонца = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	Адрес = Сред(СтруктураПодстроки.text, 2, ПозКонца - 2);

	Инлайн = Новый Структура;
	Инлайн.Вставить("extent", ПозКонца);
	Инлайн.Вставить("element", Новый Структура("name,text,attributes", "a", Адрес, Новый Структура("href", Адрес)));

	Возврат Инлайн;

КонецФункции // ИнлайнUrlTag(СтруктураПодстроки)

Функция ИнлайнUrl(СтруктураПодстроки)

	Если URLОбработаны = Истина ИЛИ СтрДлина(СтруктураПодстроки.text) < 2 ИЛИ Сред(СтруктураПодстроки.text, 2, 1) <> "/" Тогда
		Возврат Неопределено;
	КонецЕсли;

	ПозНачала = Найти(СтруктураПодстроки.context, "http://");
	ДлинаПротокола = 7;
	Если ПозНачала = 0 Тогда
		ПозНачала = Найти(СтруктураПодстроки.context, "https://");
		ДлинаПротокола = 8;
	КонецЕсли;

	Если ПозНачала = 0 ИЛИ НЕ ЭтоЛеваяГраницаСлова(СтруктураПодстроки.context, ПозНачала) Тогда
		Возврат Неопределено;
	КонецЕсли;

	//http://example.com

	ПозКонца = ПозНачала + ДлинаПротокола + 1;
	Пока ПозКонца < СтрДлина(СтруктураПодстроки.context) Цикл
		Символ = Сред(СтруктураПодстроки.context, ПозКонца + 1, 1);
		Если ЭтоСимволГраницыСлова(Символ) Тогда
			Прервать;
		КонецЕсли;
		ПозКонца = ПозКонца + 1;
	КонецЦикла;

	Адрес = Сред(СтруктураПодстроки.context, ПозНачала, ПозКонца - ПозНачала + 1);
	Инлайн = Новый Структура;
	Инлайн.Вставить("extent", СтрДлина(Адрес)); // если + 1 то Включая закрывающую >
	Инлайн.Вставить("position", ПозНачала);
	Инлайн.Вставить("element", Новый Структура("name,text,attributes", "a", Адрес, Новый Структура("href", Адрес)));

	Возврат Инлайн;

КонецФункции

Функция ИнлайнLink(СтруктураПодстроки)

	Элемент = Новый Структура("name,handler,text,attributes", "a", "line", Неопределено, Новый Структура("href,title"));

	Длина = 0;

	ОстатокСтроки = СтруктураПодстроки.text;

	Возврат Неопределено;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
/// ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ
///////////////////////////////////////////////////////////////////////////////

Функция ПолучитьИдентификаторЯзыка(Знач Стр)

	// Примеры:
	//	```bsl
	//	```
	//  ```````` bsl

	Если Лев(Стр, 3) <> "```" Тогда
		Возврат Неопределено;
	КонецЕсли;

	Стр = СтрЗаменить(Стр, "`", "");
	Стр = СтрЗаменить(Стр, " ", "");

	// TODO: если остались неалфавитные символы (;,? и т.п. кроме "-") - возвращать Неопределено

	Возврат Стр;
КонецФункции

Функция ЭтоЗавершаемыйБлок(ТипБлока)
	ЗавершаемыеБлоки=Новый Структура("Code,FencedCode");
	Возврат ЗавершаемыеБлоки.Свойство(ТипБлока);
КонецФункции

Функция ЭтоПродолжаемыйБлок(ТипБлока)
	ПродолжаемыеБлоки = Новый Структура("Code,List,Quote,Table,Markup,Comment,FencedCode");
	Возврат ПродолжаемыеБлоки.Свойство(ТипБлока);
КонецФункции

Функция НемаркерованныеТипыБлоков()

	Возврат ММ("Code");
КонецФункции

Функция ЭтоЛеваяГраницаСлова(Стр, ПозПервогоСимволаСлова)
	Если ПозПервогоСимволаСлова < 2 Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат ЭтоСимволГраницыСлова(Сред(Стр, ПозПервогоСимволаСлова - 1, 1));
КонецФункции

Функция ЭтоПраваяГраницаСлова(Стр, ПозПоследнегоСимволаСлова)
	Если ПозПоследнегоСимволаСлова >= СтрДлина(Стр) Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат ЭтоСимволГраницыСлова(Сред(Стр, ПозПоследнегоСимволаСлова + 1));
КонецФункции

Функция ЭтоСимволГраницыСлова(Символ)
	СимволыГраницыСлова = " " + Символы.ПС + Символы.Таб + Символы.ВК + "(),$~`""'[]<>^";
	Возврат Найти(СимволыГраницыСлова, Символ) > 0;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
/// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ
///////////////////////////////////////////////////////////////////////////////

Функция СокрЛПРасш(Знач Стр, УдаляемыеСимволы="") Экспорт
	Если Символы = "" Тогда
		Возврат СокрЛП(Стр);
	КонецЕсли;
	Возврат СокрПРасш(СокрЛРасш(Стр, УдаляемыеСимволы), УдаляемыеСимволы);
КонецФункции // СокрЛПРасш()

Функция СокрЛРасш(Знач Стр, УдаляемыеСимволы="")
	Если УдаляемыеСимволы = "" Тогда
		Возврат СокрЛ(Стр);
	КонецЕсли;
	Пока СтрДлина(Стр) > 0 Цикл
		Символ = Лев(Стр, 1);
		Если Найти(УдаляемыеСимволы, Символ) = 0 Тогда
			Прервать;
		КонецЕсли;
		Стр = Сред(Стр, 2);
	КонецЦикла;
	Возврат Стр;
КонецФункции // СокрЛРасш()

Функция СокрПРасш(Знач Стр, УдаляемыеСимволы="")
	Если УдаляемыеСимволы = "" Тогда
		Возврат СокрП(Стр);
	КонецЕсли;
	Пока СтрДлина(Стр) > 0 Цикл
		Символ = Прав(Стр, 1);
		Если Найти(УдаляемыеСимволы, Символ) = 0 Тогда
			Прервать;
		КонецЕсли;
		Стр = Лев(Стр, СтрДлина(Стр) - 1);
	КонецЦикла;
	Возврат Стр;
КонецФункции // СокрЛРасш()

Функция ПреобразоватьСпецСимволыHTML(Текст, НеЗаменятьДвойныеКавычки=Ложь)

	Писатель = Новый ЗаписьXML;
	Писатель.УстановитьСтроку();
	Писатель.ЗаписатьНачалоЭлемента("текст");
	Писатель.ЗаписатьТекст(Текст);
	Писатель.ЗаписатьКонецЭлемента();

	СтрокаXML = Писатель.Закрыть();

	Результат = Сред(СтрокаXML, 8, СтрДлина(СтрокаXML) - 7 - 8);

	Если НеЗаменятьДвойныеКавычки Тогда
		Результат = СтрЗаменить(Результат, "&quot;", """");
	КонецЕсли;

	Возврат Результат;
КонецФункции

Функция ДобавитьКСтроке(ИсходнаяСтрока, ДобавляемаяСтрока, ДобавляемаяСтрока2="",ДобавляемаяСтрока3="",ДобавляемаяСтрока4="",ДобавляемаяСтрока5="")
	ИсходнаяСтрока = ИсходнаяСтрока + ДобавляемаяСтрока + ДобавляемаяСтрока2 + ДобавляемаяСтрока3 + ДобавляемаяСтрока4 + ДобавляемаяСтрока5;
	Возврат ИсходнаяСтрока;
КонецФункции // ДобавитьКСтроке()

Функция ЕстьКлюч(Структура, Ключ)

	Если ТипЗнч(Структура) <> Тип("Структура") Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат Структура.Свойство(Ключ);
КонецФункции

Функция СтрПовторить(Стр, КоличествоПовторений)
	Результат = "";
	Для Н=1 По КоличествоПовторений Цикл
		Результат = Результат + Стр;
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ДобавитьЭлемент(Массив, Элемент)
	Если Элемент <> Неопределено Тогда
		Массив.Добавить(Элемент);
	КонецЕсли;
КонецФункции // ДобавитьЭлемент(Массив, Элемент)

Функция ММ(Э0=Неопределено,Э1=Неопределено,Э2=Неопределено,Э3=Неопределено,Э4=Неопределено,Э5=Неопределено, Э6=Неопределено,Э7=Неопределено,Э8=Неопределено,Э9=Неопределено) Экспорт
	М = Новый Массив;
	ДобавитьЭлемент(М, Э0);
	ДобавитьЭлемент(М, Э1);
	ДобавитьЭлемент(М, Э2);
	ДобавитьЭлемент(М, Э3);
	ДобавитьЭлемент(М, Э4);
	ДобавитьЭлемент(М, Э5);
	ДобавитьЭлемент(М, Э6);
	ДобавитьЭлемент(М, Э7);
	ДобавитьЭлемент(М, Э8);
	ДобавитьЭлемент(М, Э9);
	Возврат М;
КонецФункции

Функция ЭтоЗакодированныйСимвол(Стр)

	// Проверяет, что начало строки Стр - закодированный символ, например &quot; или &#0xABF;

	Если Лев(Стр, 1) <> "&" Тогда
		Возврат Ложь;
	КонецЕсли;

	ПозНачала = ?(Сред(Стр, 2, 1) = "#", 3, 2);
	ПозКонца = Найти(Стр, ";");
	Если ПозКонца = 0 ИЛИ ПозКонца - ПозНачала < 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	НомерСимвола = ПозНачала;
	Пока НомерСимвола < ПозКонца Цикл
		Символ = Сред(Стр, НомерСимвола, 1);
		Если НЕ ЭтоБукваЛатинскогоАлфавита(Символ) И НЕ ЭтоЦифра(Символ) Тогда
			Возврат Ложь;
		КонецЕсли;
		НомерСимвола = НомерСимвола + 1;
	КонецЦикла;

	Возврат Ложь;

КонецФункции

Функция ЭтоБукваЛатинскогоАлфавита(Символ)
	Возврат Найти("ABCDEFGHIJKLMNOPQRSTUVWXYZ", ВРег(Символ)) > 0;
КонецФункции // ЭтоБуква()

Функция ЭтоЦифра(Символ)
	Возврат Найти("0123456789", Символ) > 0;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
/// ИНИЦИАЛИЗАЦИЯ И ОСНОВНАЯ ПРОГРАММА
///////////////////////////////////////////////////////////////////////////////

Функция Инициализировать()

	ТипыБлоков = Новый Соответствие;
	ТипыБлоков.Вставить("#", ММ("Header"));
	ТипыБлоков.Вставить("*", ММ("Rule", "List"));
	ТипыБлоков.Вставить("+", ММ("List"));
	ТипыБлоков.Вставить("-", ММ("SetextHeader", "Table", "Rule", "List"));
	ТипыБлоков.Вставить("0", ММ("List"));
	ТипыБлоков.Вставить("1", ММ("List"));
	ТипыБлоков.Вставить("2", ММ("List"));
	ТипыБлоков.Вставить("3", ММ("List"));
	ТипыБлоков.Вставить("4", ММ("List"));
	ТипыБлоков.Вставить("5", ММ("List"));
	ТипыБлоков.Вставить("6", ММ("List"));
	ТипыБлоков.Вставить("7", ММ("List"));
	ТипыБлоков.Вставить("8", ММ("List"));
	ТипыБлоков.Вставить("9", ММ("List"));
	ТипыБлоков.Вставить(":", ММ("Table"));
	ТипыБлоков.Вставить("<", ММ("Comment", "Markup"));
	ТипыБлоков.Вставить("=", ММ("SetextHeader"));
	ТипыБлоков.Вставить(">", ММ("Quote"));
	ТипыБлоков.Вставить("[", ММ("Reference"));
	ТипыБлоков.Вставить("_", ММ("Rule"));
	ТипыБлоков.Вставить("`", ММ("FencedCode"));
	ТипыБлоков.Вставить("|", ММ("Table"));
	ТипыБлоков.Вставить("~", ММ("FencedCode"));

	ТипыИнлайнов = Новый Соответствие;
	ТипыИнлайнов.Вставить("!", ММ("Image"));
	ТипыИнлайнов.Вставить("""", ММ("SpecialCharacter"));
	ТипыИнлайнов.Вставить("*" , ММ("Emphasis"));
	ТипыИнлайнов.Вставить("_" , ММ("Emphasis"));
	ТипыИнлайнов.Вставить("&" , ММ("SpecialCharacter"));
	ТипыИнлайнов.Вставить("[" , ММ("Link"));
	ТипыИнлайнов.Вставить("<" , ММ("UrlTag", "EmailTag", "Markup", "SpecialCharacter"));
	ТипыИнлайнов.Вставить(":" , ММ("Url"));
	ТипыИнлайнов.Вставить(">" , ММ("SpecialCharacter"));
	ТипыИнлайнов.Вставить("`" , ММ("Code"));
	ТипыИнлайнов.Вставить("~" , ММ("Strikethrough"));
	ТипыИнлайнов.Вставить("\" , ММ("EscapeSequence"));

КонецФункции

Инициализировать();
