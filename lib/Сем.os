// MIT License
// Copyright (c) 2020 vasvl123
// https://github.com/vasvl123/useyourmind

Перем дПравила;
Перем Правила;
Перем Формы;


Функция УзелСвойство(Узел, Свойство) Экспорт
	УзелСвойство = Неопределено;
	Если НЕ Узел = Неопределено Тогда
		Узел.Свойство(Свойство, УзелСвойство);
	КонецЕсли;
	Возврат УзелСвойство;
КонецФункции // УзелСвойство(Узел)


Функция ИмяЗначение(Имя, Значение = "")
	Возврат Новый Структура("Имя, Значение", Имя, Значение);
КонецФункции

Процедура ПостроитьИндекс(пУзел)
	пУзел.Вставить("с", Новый Соответствие);
	дУзел = пУзел.Дочерний;
	Пока НЕ дУзел = Неопределено Цикл
		ПостроитьИндекс(дУзел);
		ин = 0;
		Пока НЕ пУзел.с.Получить(дУзел.Имя + "_" + ин) = Неопределено Цикл
			ин = ин + 1;
		КонецЦикла;
		пУзел.с.Вставить(дУзел.Имя + "_" + ин, дУзел);
		дУзел = дУзел.Соседний;
	КонецЦикла;
КонецПроцедуры

Функция Предложение_Свойства(Данные, оУзел) Экспорт

	Если дПравила = Неопределено Тогда // Загрузить правила анализа
		Запрос = Новый Структура("sdata, data", Данные.Процесс.Источник, "semdata");
		дПравила = Данные.Процесс.ПолучитьДанные(Новый Структура("Запрос", Запрос));
		Если дПравила = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Если Правила = Неопределено Тогда // построить индекс
		Правила = дПравила.Корень.Дочерний.Дочерний;
		ПостроитьИндекс(Правила);
	КонецЕсли;
	Если Формы = Неопределено Тогда // формы слов
		Формы = Данные.НовыйДочерний(Данные.Корень.Свойства, ИмяЗначение("Формы"), , Истина);
		Формы.Вставить("с", Новый Соответствие);
	КонецЕсли;

	Если НЕ оУзел.Свойство("Свойства") Тогда // новый объект
		Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""), Данные.Служебный(оУзел));
		шСвойства = "
		|Токены
		|Разбор: Нет
		|*Задачи
		|*Вид";
		Данные.СоздатьСвойства(Свойства, шСвойства);
		оУзел.Вставить("Свойства", Свойства);
	КонецЕсли;

КонецФункции

Функция Предложение_Модель(Данные, Свойства, Изменения) Экспорт
	Перем Обновить;

	оУзел = Свойства.Родитель;
	Если НЕ УзелСвойство(оУзел, "Обновить") = Ложь Тогда

		Если Свойства.д.Разбор.Значение = "Нет" Тогда
			пр = "";
			Свойства.д.Токены.Вставить("с", Новый Соответствие);
			Если Свойства.д.Свойство("Текст", пр) Тогда
				пр = СтрЗаменить(пр, ".", " . ");
				пр = СтрЗаменить(пр, ",", " , ");
				пр = СтрЗаменить(пр, "!", " ! ");
				пр = СтрЗаменить(пр, "?", " ? ");
				пр = СтрЗаменить(пр, ":", " : ");
				пр = СтрЗаменить(пр, ";", " ; ");
				пр = СтрЗаменить(пр, "«", " « ");
				пр = СтрЗаменить(пр, "»", " » ");
				пр = СтрЗаменить(пр, """", " "" ");
				пр = СтрЗаменить(пр, "'", " ' ");
				м = СтрРазделить(пр, " ");
				Для каждого сл Из м Цикл
					Если НЕ сл = "" Тогда
						т = Данные.НовыйДочерний(Свойства.д.Токены, ИмяЗначение(сл, ""), , Истина);
						Если НЕ (сл = "." ИЛИ сл = "," ИЛИ сл = "!" ИЛИ сл = "?" ИЛИ сл = ":" ИЛИ сл = ";" ИЛИ сл = "«" ИЛИ сл = "»" ИЛИ сл = """" ИЛИ сл = "'" ИЛИ сл = "-" ИЛИ сл = "–") Тогда
							о = Данные.НовыйДочерний(т, ИмяЗначение("Отношения", ""), , Истина);
							т.Вставить("Отношения", о);
							Если Формы.с.Получить(ВРег(сл)) = Неопределено Тогда
								всл = ВРег(сл);
								ф = Данные.НовыйДочерний(Формы, ИмяЗначение(всл), , Истина);
								Формы.с.Вставить(всл, ф);
								Запрос = Новый Структура("Данные, Слова, Свойства, Формы, cmd", Данные, всл, Свойства, ф, "ФормыСлов");
								стрЗ = Данные.Процесс.НоваяЗадача(Запрос, "Служебный");
								Данные.НовыйДочерний(Свойства.д.Задачи, ИмяЗначение(стрЗ.ИдЗадачи, ""), , Истина);
							КонецЕсли;
						КонецЕсли;
						Свойства.д.Токены.с.Вставить(сл, т);
					КонецЕсли;
				КонецЦикла;
				Свойства.д.Разбор.Значение = "Формы";
				Обновить = Истина;
			Иначе // нечего разбирать
				оУзел.Вставить("Обновить", Ложь);
			КонецЕсли;
		ИначеЕсли Свойства.д.Разбор.Значение = "Формы" Тогда
			// проверить все ли слова разобраны
			Если Свойства.д.Задачи.Дочерний = Неопределено Тогда
				Свойства.д.Разбор.Значение = "Токены";
			КонецЕсли;
			Обновить = Истина;
		ИначеЕсли Свойства.д.Разбор.Значение = "Токены" Тогда
			// можно выполнять семантический разбор
			Для каждого т1 Из Свойства.д.Токены.с Цикл
				ток1 = т1.Значение;
				ток1Формы = Формы.с.Получить(ВРег(т1.Ключ));
				Если НЕ ток1Формы = Неопределено Тогда
					фУзел1 = ток1Формы.Дочерний;
					Пока НЕ фУзел1 = Неопределено Цикл
						и1 = 0;
						Пока Истина Цикл
							п1 = Правила.с.Получить(фУзел1.Значение + "_" + и1);
							Если п1 = Неопределено Тогда
								Прервать;
							КонецЕсли;
							Для каждого т2 Из Свойства.д.Токены.с Цикл
								ток2 = т2.Значение;
								Если НЕ ток1 = ток2 Тогда
									ток2Формы = Формы.с.Получить(ВРег(т2.Ключ));
									Если НЕ ток2Формы = Неопределено Тогда
										фУзел2 = ток2Формы.Дочерний;
										Пока НЕ фУзел2 = Неопределено Цикл
											и2 = 0;
											Пока Истина Цикл
												п2 = п1.с.Получить(фУзел2.Значение + "_" + и2);
												Если п2 = Неопределено Тогда
													Прервать;
												КонецЕсли;
												// найдено подходящее правило
												Данные.НовыйДочерний(ток1.Отношения, ИмяЗначение(п2.Значение, ток2.Имя), , Истина);
												Данные.НовыйДочерний(Свойства.д.Вид, ИмяЗначение("p", ток1.Имя + " " + п2.Значение + " " + ток2.Имя), Истина, Истина);
												и2 = и2 + 1;
											КонецЦикла;
											фУзел2 = фУзел2.Соседний;
										КонецЦикла;
									КонецЕсли;
								КонецЕсли;
							КонецЦикла;
							и1 = и1 + 1;
						КонецЦикла;
						фУзел1 = фУзел1.Соседний;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;

			Свойства.д.Разбор.Значение = "Выполнен";
			Обновить = Истина;
		Иначе
			оУзел.Вставить("Обновить", Ложь);
		КонецЕсли;
	КонецЕсли;

	Возврат Обновить;

КонецФункции


Функция Токен_Свойства(Данные, оУзел) Экспорт

	Если НЕ оУзел.Свойство("Свойства") Тогда // новый объект
		Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""), Данные.Служебный(оУзел));
		шСвойства = "
		|";
		Данные.СоздатьСвойства(Свойства, шСвойства);
		оУзел.Вставить("Свойства", Свойства);
	КонецЕсли;

КонецФункции

Функция Токен_Модель(Данные, Свойства, Изменения) Экспорт

	оУзел = Свойства.Родитель;
	Если НЕ УзелСвойство(оУзел, "Обновить") = Ложь Тогда
	КонецЕсли;

КонецФункции
