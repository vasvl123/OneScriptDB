// MIT License
// Copyright (c) 2021 vasvl123
// https://github.com/vasvl123/onesharp.net

using System;

namespace onesharp.lib
{
    class tracer : Onesharp
    {

        public tracer ЭтотОбъект { get { return this; } }

        public tracer() : base("tracer") 
        { 
        }

        double пи;
        double МАКС_ЧИСЛО;
        int ГЛУБИНА_РЕКУРСИИ;
        Вектор НулевойВектор;
        Вектор ЕдиничныйВектор;
        Вектор ЕдиничныйВекторX;
        Вектор ЕдиничныйВекторY;
        Вектор ЕдиничныйВекторZ;
        Вектор ЦветФона;
        Вектор ЦветБелый;
        Вектор ЦветЖелтый;
        Материал ПлиткаБелая;
        Материал ПлиткаЖелтая;
        Массив Сферы; 
        Массив Освещение;
        int Ширина;
        int Высота;
        double УголЗрения;
        Массив Кадр;
   
        struct Вектор
        {
            public Вектор(double _x = 0, double _y = 0, double _z = 0)
            {
                x = _x;
                y = _y;
                z = _z;
            }

            public double x;
            public double y;
            public double z;
        }

        Вектор Новый_Вектор(double x = 0, double y = 0, double z = 0)
        {
            return new Вектор(x, y, z);
        } // Новый_Вектор()
    
        void Вектор_Печать(Вектор В1)
        {
            Сообщить("(" + В1.x + "," + В1.y + "," + В1.z + ")");
        } // Вектор_Печать()
    
        Вектор Вектор_Минус(Вектор В1)
        {
            return new Вектор(- В1.x, - В1.y, - В1.z);
        } // Вектор_Минус()
    
        Вектор Вектор_Сумма(Вектор В1, Вектор В2)
        {
            return new Вектор(В1.x + В2.x, В1.y + В2.y, В1.z + В2.z);
        } // Вектор_Сумма()
    
        Вектор Вектор_Разность(Вектор В1, Вектор В2)
        {
            return new Вектор(В1.x - В2.x, В1.y - В2.y, В1.z - В2.z);
        } // Вектор_Разность()
    
        Вектор Вектор_Умножить(Вектор В1, double ч)
        {
            return new Вектор(В1.x * ч, В1.y * ч, В1.z * ч);
        } // Вектор_Умножить()
    
        double Вектор_СкалярноеПр(Вектор В1, Вектор В2)
        {
            return В1.x * В2.x + В1.y * В2.y + В1.z * В2.z;
        } // Вектор_СкалярноеПр()
    
        double Вектор_Норма(Вектор В1)
        {
            return Sqrt(В1.x * В1.x + В1.y * В1.y + В1.z * В1.z);
        } // Вектор_Норма()
    
        double Вектор_КвНормы(Вектор В1)
        {
            return В1.x * В1.x + В1.y * В1.y + В1.z * В1.z;
        } // Вектор_КвНормы()
    
        Вектор Вектор_Нормализация(Вектор В1)
        {
            var норма = Вектор_Норма(В1);
            В1.x = В1.x / норма;
            В1.y = В1.y / норма;
            В1.z = В1.z / норма;
            return В1;
        } // Вектор_Нормализация()
    
        double Abs(double ч)
        {
            return (ч < 0 ? - ч : ч);
        } // Abs()
    
        int Норм_Цвет(double цв)
        {
            return Цел(255 * Макс(0, Мин(1, цв)));
        } // Норм_Цвет()
    
        struct Сфера
        {
            public Сфера(Вектор _ц, double _р, Материал _мат)
            {
                Центр = _ц;
                Радиус = _р;
                Материал = _мат;
            }

            public Вектор Центр;
            public double Радиус;
            public Материал Материал;
        }
    
        Сфера Новая_Сфера(Вектор ц, double р, Материал мат)
        {
            return new Сфера(ц, р, мат);
        } // Новая_Сфера()
    
        struct Свет
        {
            public Свет(Вектор _п, double _я)
            {
                Поз = _п;
                Ярк = _я;
            }

            public Вектор Поз;
            public double Ярк;
        }

        Свет Новый_Свет(Вектор поз, double ярк)
        {
            return new Свет(поз, ярк);
        } // Новый_Свет()
    
        struct Материал
        {
            public Материал(Вектор Цв, double Ал0, double Ал1, double Ал2, double Ал3, double Отр, double Пр)
            {
                Цвет = Цв;
                Альб0 = Ал0;
                Альб1 = Ал1;
                Альб2 = Ал2;
                Альб3 = Ал3;
                ЭкспОтраж = Отр;
                КПрелом = Пр;
            }

            public Вектор Цвет;
            public double Альб0;
            public double Альб1;
            public double Альб2;
            public double Альб3;
            public double ЭкспОтраж;
            public double КПрелом;
        }
    
        Материал Новый_Материал(Вектор Цв, double Ал0, double Ал1, double Ал2, double Ал3, double Отр, double Пр)
        {
            return new Материал(Цв, Ал0, Ал1, Ал2, Ал3, Отр, Пр);
        } // Новый_Материал()
    
        bool Сфера_Пересечение(Сфера Сф, Вектор Исх, Вектор Напр, ref double Расст)
        {
            var КЦентру = Вектор_Разность(Сф.Центр, Исх);
            var пр = Вектор_СкалярноеПр(КЦентру, Напр);
            var д2 = Вектор_КвНормы(КЦентру) - пр * пр;
            var р2 = Сф.Радиус * Сф.Радиус;
            if (д2 > р2)
            {
                return Ложь;
            }
            var р = Sqrt(р2 - д2);
            Расст = пр - р;
            if (Расст < 0)
            {
                Расст = пр + р;
                if (Расст < 0)
                {
                    return Ложь;
                }
            }
            return Истина;
        } // Сфера_Пересечение()
    
        bool НайтиПересечения(Вектор Исх, Вектор Напр, ref object _Точка, ref object Нормаль, ref object Материал)
        {
            double Расст = 0;
            var МинРасст = МАКС_ЧИСЛО;
            foreach (Сфера Сф in Сферы)
            {
                if ((Сфера_Пересечение(Сф, Исх, Напр, ref Расст)) && (Расст < МинРасст))
                {
                    МинРасст = Расст;
                    _Точка = Вектор_Сумма(Исх, Вектор_Умножить(Напр, Расст));
                    Вектор Точка = (Вектор)_Точка;
                    Нормаль = Вектор_Нормализация(Вектор_Разность(Точка, Сф.Центр));
                    Материал = Сф.Материал;
                }
            }
            // квадрат (-10,-10,-4) - (10,-30,-4)
            if (Напр.y < - 0.001)
            {
                var р = - (Исх.y + 4) / Напр.y;
                if (0 < р && р < МинРасст)
                {
                    var Т = Вектор_Умножить(Напр, р);
                    Т = Вектор_Сумма(Т, Исх);
                    if (Abs(Т.x) < 10 && - 30 < Т.z && Т.z < - 10)
                    {
                        МинРасст = р;
                        _Точка = Т;
                        Вектор Точка = (Вектор)_Точка;
                        Нормаль = ЕдиничныйВекторY;
                        Материал = ((Цел(0.5 * Точка.x + 1000) + Цел(0.5 * Точка.z)) % 2 == 1 ? ПлиткаБелая : ПлиткаЖелтая);
                    }
                }
            }
            return МинРасст < 1000;
        } // НайтиПересечения()
    
        Вектор Отражение(Вектор Луч, Вектор Норм)
        {
            return Вектор_Разность(Луч, Вектор_Умножить(Норм, 2 * Вектор_СкалярноеПр(Луч, Норм)));
        } // Отражение()
    
        Вектор Преломление(Вектор Луч, Вектор Норм, double КоэфПр)
        {
            double эта; 
            Вектор Н;
             
            if (КоэфПр == 1)
            {
                return Луч;
            }
            var CosI = - Макс(- 1, Мин(1, Вектор_СкалярноеПр(Луч, Норм)));
            if (CosI >= 0)
            {
                эта = 1 / КоэфПр;
                Н = Норм;
            }
            else
            {
                CosI = - CosI;
                эта = КоэфПр;
                Н = Вектор_Минус(Норм);
            }
            double К = 1 - эта * эта * (1 - CosI * CosI);
            if (К < 0)
            {
                return ЕдиничныйВекторX;
            }
            return Вектор_Сумма(Вектор_Умножить(Луч, эта), Вектор_Умножить(Н, эта * CosI - Sqrt(К)));
        } // Преломление()
    
        Вектор ТрассироватьЛуч(Вектор Исх, Вектор Напр, int Глубина = 0)
        {
            object _Точка = null;
            object _Нормаль = null;
            object _Материал = null;
            if (Глубина > ГЛУБИНА_РЕКУРСИИ || !(НайтиПересечения(Исх, Напр, ref _Точка, ref _Нормаль, ref _Материал)))
            {
                return ЦветФона;
            }
            Вектор Точка = (Вектор)_Точка;
            Вектор Нормаль = (Вектор)_Нормаль;
            Материал Материал = (Материал)_Материал;
            var СдвигПоНормали = Вектор_Умножить(Нормаль, 0.001);
            var ОтражНапр = Отражение(Напр, Нормаль);
            // нормализовано
            var ОтражИсх = (Вектор_СкалярноеПр(ОтражНапр, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
            var ОтражЦвет = ТрассироватьЛуч(ОтражИсх, ОтражНапр, Глубина + 1);
            var ПреломНапр = Вектор_Нормализация(Преломление(Напр, Нормаль, Материал.КПрелом));
            var ПреломИсх = (Вектор_СкалярноеПр(ПреломНапр, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
            var ПреломЦвет = ТрассироватьЛуч(ПреломИсх, ПреломНапр, Глубина + 1);
            double Яркость = 0;
            double Блик = 0;
            foreach (Свет Свет in Освещение)
            {
                var НапрКСвету = Вектор_Нормализация(Вектор_Разность(Свет.Поз, Точка));
                var РасстДоСвета = Вектор_КвНормы(Вектор_Разность(Свет.Поз, Точка));
                var ТеньИсх = (Вектор_СкалярноеПр(НапрКСвету, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
                object _ТеньТочка = null;
                object _ТеньНормаль = null;
                object _ВремМатериал = null;
                if (НайтиПересечения(ТеньИсх, НапрКСвету, ref _ТеньТочка, ref _ТеньНормаль, ref _ВремМатериал) && Вектор_КвНормы(Вектор_Разность((Вектор)_ТеньТочка, ТеньИсх)) < РасстДоСвета)
                {
                    continue;
                }
                Яркость = Яркость + Свет.Ярк * Макс(0, Вектор_СкалярноеПр(НапрКСвету, Нормаль));
                //powf(std::max(0.f, -reflect(-light_dir, N)*dir), material.specular_exponent)*lights[i].intensity;
                Блик = Блик + Свет.Ярк * Pow(Макс(0, Вектор_СкалярноеПр(Отражение(НапрКСвету, Нормаль), Напр)), Материал.ЭкспОтраж);
            }
            return Вектор_Сумма(Вектор_Сумма(Вектор_Сумма(Вектор_Умножить(Материал.Цвет, Яркость * Материал.Альб0), Вектор_Умножить(ЕдиничныйВектор, Блик * Материал.Альб1)), Вектор_Умножить(ОтражЦвет, Материал.Альб2)), Вектор_Умножить(ПреломЦвет, Материал.Альб3));
        } // ТрассироватьЛуч()
    
        void Рендер()
        {
            var Камера = Новый_Вектор(0, 0, 0);
            var Напр_Z = - Высота / (2 * Tan(УголЗрения / 2));
            for (int верт = 0; верт <= Высота - 1; верт++)
            {
                int линия = верт * Ширина;
                var Напр_Y = - (верт + 0.5) + Высота / 2;
                for (int гор = 0; гор <= Ширина - 1; гор++)
                {
                    var Напр_X = (гор + 0.5) - Ширина / 2;
                    var Направление = Вектор_Нормализация(new Вектор(Напр_X, Напр_Y, Напр_Z));
                    Кадр[линия + гор] = ТрассироватьЛуч(Камера, Направление);
                }
            }
        } // Рендер()
    
        void СохранитьКадр(string ИмяФайла)
        {
            var файл = Новый.ТекстовыйДокумент();
            файл.ДобавитьСтроку("P3");
            файл.ДобавитьСтроку("" + Ширина + " " + Высота);
            файл.ДобавитьСтроку("255");
            for (int п = 0; п <= Высота * Ширина - 1; п++)
            {
                var Пиксел = (Вектор)Кадр[п];
                var МаксИнт = Макс(Пиксел.x, Макс(Пиксел.y, Пиксел.z));
                if (МаксИнт > 1)
                {
                    МаксИнт = 1 / МаксИнт;
                    Пиксел.x = Пиксел.x * МаксИнт;
                    Пиксел.y = Пиксел.y * МаксИнт;
                    Пиксел.z = Пиксел.z * МаксИнт;
                }
                файл.ДобавитьСтроку("" + Норм_Цвет(Пиксел.x) + " " + Норм_Цвет(Пиксел.y) + " " + Норм_Цвет(Пиксел.z));
            }
            файл.Записать(ИмяФайла, "ANSI");
        } // СохранитьКадр()
    
        
        public object УзелСвойство(Структура Узел, string Свойство)
        {
            object УзелСвойство = null;
            if (!(Узел == Неопределено))
            {
                Узел.Свойство(Свойство, out УзелСвойство);
            }
            return УзелСвойство;
        } // УзелСвойство(Узел)

        public Узел ИмяЗначение(string Имя = "", object _Значение = null)
        {
            var Значение = (_Значение is null) ? "" : _Значение;
            return Узел.Новый("Имя, Значение", Имя, Значение);
        }
    

        public string Пиксель_Свойства(pagedata Данные, Узел оУзел)
        {
            object Свойства = null;
            var шСвойства = "";

            if (!(оУзел.Свойство("Свойства", out Свойства)))
            { // новый объект
                Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""), Истина);
            }

            шСвойства = @"
            |*События
            |*Гор
            |*Вер
            |*Шыр
            |*Выс
            |*Цвет
            |*Вид
            |	: Если
            |		: Равно
            |			З: Цвет
            |			Строка:
            |		П: Содержимое
            |		З: Цвет";

            Данные.СоздатьСвойства(Свойства as Узел, шСвойства, "Только");
            оУзел.Вставить("Свойства", Свойства);

            return null;
        }

        public void Пиксель_Модель(pagedata Данные, Узел Свойства, Соответствие Изменения)
        {
            var оУзел = Свойства.Родитель;

            if (!(УзелСвойство(оУзел, "Обновить") as bool? == Ложь))
            {
                var _выс = Свойства.д.Выс.Значение;
                var _шыр = Свойства.д.Выс.Значение;

                if (ЗначениеЗаполнено(Свойства.д.Цвет.Значение))
                {
                    var Камера = Новый_Вектор(0, 0, 0);
                    var Напр_Z = - _выс / (2 * Tan(УголЗрения / 2));
                    var _верт = Свойства.д.Вер.Значение;
                    var Напр_Y = - (_верт + 0.5) + _выс / 2;
                    var _гор = Свойства.д.Гор.Значение;
                    var Напр_X = (_гор + 0.5) - _шыр / 2;
                    var Направление = Вектор_Нормализация(new Вектор(Напр_X, Напр_Y, Напр_Z));
                    var цв = ТрассироватьЛуч(Камера, Направление);
                    var цвз = "rgb(" + Норм_Цвет(цв.x) + ", " + Норм_Цвет(цв.y) + ", " + Норм_Цвет(цв.z) + ")";

                    if (_шыр < 32) {
                        
                        // разделить пиксель

                        var п = Свойства;

                        for (int верт = 0; верт < 2; верт++)
                        {
                            п = Данные.НовыйДочерний(оУзел, ИмяЗначение("div"), Истина, Истина);
                            Данные.НовыйАтрибут(п, ИмяЗначение("style", "display:flex"), Истина);
                            for (int гор = 0; гор < 2; гор++)
                            {
                                var вп = Данные.НовыйДочерний(п, ИмяЗначение("О", "tracer.Пиксель"), Истина, Истина);
                                var свп = Данные.ОбработатьОбъект(вп, Истина) as Узел;
                                свп.д.Гор.Значение = _гор * 2 + гор;
                                свп.д.Вер.Значение = _верт * 2 + верт;
                                свп.д.Шыр.Значение = _шыр * 2;
                                свп.д.Выс.Значение = _выс * 2;
                                свп.д.Цвет.Значение = "<div style='width:" + 5 * 32 / _шыр + "px; height:" + 5 * 32 / _выс + "px; background-color: " + цвз + "'></div>";
                            }

                        }

                        Свойства.д.Цвет.Значение = "";

                    }

                }

            }            
        }
        
        
        public string Кадр_Свойства(pagedata Данные, Узел оУзел)
        {
            object Свойства = null;
            var шСвойства = "";

            if (!(оУзел.Свойство("Свойства", out Свойства)))
            { // новый объект
                Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""));
            }

            шСвойства = @"
            |*События";
            Данные.СоздатьСвойства(Свойства as Узел, шСвойства, "Только");
            оУзел.Вставить("Свойства", Свойства);

            return null;
        }


        public void Кадр_Модель(pagedata Данные, Узел Свойства, Соответствие Изменения)
        {
            var оУзел = Свойства.Родитель;

            // обработать события
            if (Изменения.Получить(Свойства.д.События) as bool? == Истина)
            {
                var дУзел = Свойства.д.События.Дочерний as Узел;
                if (!(дУзел is null))
                {
                    var мСобытие = Стр.Разделить(дУзел.Значение as string, Символы.Таб);
                    var тСобытие = мСобытие[0];
                    if (тСобытие == "ПриНажатии")
                    {
                        var сУзел = Данные.ПолучитьУзел(мСобытие[1]);

                        var ЗначениеКнопка = УзелСвойство(дУзел, "Параметры") as string;
                        if (!(ЗначениеКнопка is null))
                        {

                            if (ЗначениеКнопка == "sent")
                            {
                            }
                        }
                    }
                    else
                    { // изменение полей
                    }

                }

                Данные.УдалитьУзел(дУзел);
                Изменения.Вставить(Свойства.д.События, Истина);
                оУзел.Вставить("Обновить", Истина);
            }

            if (!(УзелСвойство(оУзел, "Обновить") as bool? == Ложь))
            {

                пи = 3.14159265359;
                МАКС_ЧИСЛО = 999999999999999;
                ГЛУБИНА_РЕКУРСИИ = 2;
                НулевойВектор = Новый_Вектор(0, 0, 0);
                ЕдиничныйВектор = Новый_Вектор(1, 1, 1);
                ЕдиничныйВекторX = Новый_Вектор(1, 0, 0);
                ЕдиничныйВекторY = Новый_Вектор(0, 1, 0);
                ЕдиничныйВекторZ = Новый_Вектор(0, 0, 1);
                ЦветБелый = ЕдиничныйВектор;
                ЦветЖелтый = Новый_Вектор(1, 0.7, 0.3);
                Ширина = 32;
                Высота = 32;
                УголЗрения = пи / 3;
                Кадр = Новый.Массив(Ширина * Высота);
                ЦветФона = Новый_Вектор(0.2, 0.7, 0.8);
                var Серый = Новый_Материал(Новый_Вектор(0.4, 0.4, 0.3), 0.6, 0.3, 0.1, 0, 50, 1);
                var Стекло = Новый_Материал(Новый_Вектор(0.6, 0.7, 0.8), 0, 0.5, 0.1, 0.8, 125, 1.5);
                var Красный = Новый_Материал(Новый_Вектор(0.3, 0.1, 0.1), 0.9, 0.1, 0.0, 0, 10, 1);
                var Зеркало = Новый_Материал(Новый_Вектор(1.0, 1.0, 1.0), 0, 10.0, 0.8, 0, 1425, 1);
                ПлиткаБелая = Новый_Материал(Вектор_Умножить(ЦветБелый, 0.3), 1, 0, 0, 0, 0, 1);
                ПлиткаЖелтая = Новый_Материал(Вектор_Умножить(ЦветЖелтый, 0.3), 1, 0, 0, 0, 0, 1);
                Сферы = Новый.Массив();
                Сферы.Добавить(Новая_Сфера(Новый_Вектор(- 3, 0, - 16), 2, Серый));
                Сферы.Добавить(Новая_Сфера(Новый_Вектор(- 1.0, - 1.5, - 12), 2, Стекло));
                Сферы.Добавить(Новая_Сфера(Новый_Вектор(1.5, - 0.5, - 18), 3, Красный));
                Сферы.Добавить(Новая_Сфера(Новый_Вектор(7, 5, - 18), 4, Зеркало));
                Освещение = Новый.Массив();
                Освещение.Добавить(Новый_Свет(Новый_Вектор(- 20, 20, 20), 1.5));
                Освещение.Добавить(Новый_Свет(Новый_Вектор(30, 50, - 25), 1.8));
                Освещение.Добавить(Новый_Свет(Новый_Вектор(30, 20, 30), 1.7));
                //var т0 = ТекущаяУниверсальнаяДатаВМиллисекундах();
                //Рендер();
                //var т1 = ТекущаяУниверсальнаяДатаВМиллисекундах();
                //Сообщить("~"+ Цел(т1-т0) );
                //СохранитьКадр(ОбъединитьПути(ТекущийКаталог(),"out.ppm"));

                var вп = Данные.НовыйСоседний(Свойства, ИмяЗначение("О", "tracer.Пиксель"), Истина);
                var свп = Данные.ОбработатьОбъект(вп, Истина) as Узел;
                свп.д.Гор.Значение = 0;
                свп.д.Вер.Значение = 0;
                свп.д.Шыр.Значение = 1;
                свп.д.Выс.Значение = 1;
                свп.д.Цвет.Значение = "Старт";

            }

        }

    }
}
