// MIT License
// Copyright (c) 2021 vasvl123
// https://github.com/vasvl123/onesharp.net

using System;

namespace onesharp.lib
{
    class tracer : Onesharp
    {

        public tracer ЭтотОбъект { get { return this; } }

        public tracer() : base("tracer") 
        { 
        }

        double пи;
        double МАКС_ЧИСЛО;
        int ГЛУБИНА_РЕКУРСИИ;
        Структура НулевойВектор;
        Структура ЕдиничныйВектор;
        Структура ЕдиничныйВекторX;
        Структура ЕдиничныйВекторY;
        Структура ЕдиничныйВекторZ;
        Структура ЦветФона;
        Структура ЦветБелый;
        Структура ЦветЖелтый;
        Структура ПлиткаБелая;
        Структура ПлиткаЖелтая;
        Массив Сферы; 
        Массив Освещение;
        int Ширина;
        int Высота;
        double УголЗрения;
        Массив Кадр;
    
        Структура Новый_Вектор(double x = 0, double y = 0, double z = 0)
        {
            return Новый.Структура("x,y,z", x, y, z);
        } // Новый_Вектор()
    
        void Вектор_Печать(Структура В1)
        {
            Сообщить("(" + В1.с.x + "," + В1.с.y + "," + В1.с.z + ")");
        } // Вектор_Печать()
    
        Структура Вектор_Минус(Структура В1)
        {
            return Новый_Вектор(- В1.с.x, - В1.с.y, - В1.с.z);
        } // Вектор_Минус()
    
        Структура Вектор_Сумма(Структура В1, Структура В2)
        {
            return Новый_Вектор(В1.с.x + В2.с.x, В1.с.y + В2.с.y, В1.с.z + В2.с.z);
        } // Вектор_Сумма()
    
        Структура Вектор_Разность(Структура В1, Структура В2)
        {
            return Новый_Вектор(В1.с.x - В2.с.x, В1.с.y - В2.с.y, В1.с.z - В2.с.z);
        } // Вектор_Разность()
    
        Структура Вектор_Умножить(Структура В1, double ч)
        {
            return Новый_Вектор(В1.с.x * ч, В1.с.y * ч, В1.с.z * ч);
        } // Вектор_Умножить()
    
        double Вектор_СкалярноеПр(Структура В1, Структура В2)
        {
            return В1.с.x * В2.с.x + В1.с.y * В2.с.y + В1.с.z * В2.с.z;
        } // Вектор_СкалярноеПр()
    
        double Вектор_Норма(Структура В1)
        {
            return Sqrt(В1.с.x * В1.с.x + В1.с.y * В1.с.y + В1.с.z * В1.с.z);
        } // Вектор_Норма()
    
        double Вектор_КвНормы(Структура В1)
        {
            return В1.с.x * В1.с.x + В1.с.y * В1.с.y + В1.с.z * В1.с.z;
        } // Вектор_КвНормы()
    
        Структура Вектор_Нормализация(Структура В1)
        {
            var норма = Вектор_Норма(В1);
            В1.с.x = В1.с.x / норма;
            В1.с.y = В1.с.y / норма;
            В1.с.z = В1.с.z / норма;
            return В1;
        } // Вектор_Нормализация()
    
        double Abs(double ч)
        {
            return (ч < 0 ? - ч : ч);
        } // Abs()
    
        int Норм_Цвет(int цв)
        {
            return (int)Цел(255 * Макс(0, Мин(1, цв)));
        } // Норм_Цвет()
    
        Структура Новая_Сфера(Структура ц, double р, Структура мат)
        {
            return Новый.Структура("Центр,Радиус, Материал", ц, р, мат);
        } // Новая_Сфера()
    
        Структура Новый_Свет(Структура поз, double ярк)
        {
            return Новый.Структура("Поз, Ярк", поз, ярк);
        } // Новый_Свет()
    
        Структура Новый_Материал(Структура Цв, double Ал0, double Ал1, double Ал2, double Ал3, double Отр, double Пр)
        {
            return Новый.Структура("Цвет, Альб0,Альб1,Альб2,Альб3, ЭкспОтраж, КПрелом", Цв, Ал0, Ал1, Ал2, Ал3, Отр, Пр);
        } // Новый_Материал()
    
        bool Сфера_Пересечение(Структура Сф, Структура Исх, Структура Напр, double Расст)
        {
            var КЦентру = Вектор_Разность(Сф.с.Центр, Исх);
            var пр = Вектор_СкалярноеПр(КЦентру, Напр);
            var д2 = Вектор_КвНормы(КЦентру) - пр * пр;
            var р2 = Сф.с.Радиус * Сф.с.Радиус;
            if (д2 > р2)
            {
                return Ложь;
            }
            var р = Sqrt(р2 - д2);
            Расст = пр - р;
            if (Расст < 0)
            {
                Расст = пр + р;
                if (Расст < 0)
                {
                    return Ложь;
                }
            }
            return Истина;
        } // Сфера_Пересечение()
    
        bool НайтиПересечения(Структура Исх, Структура Напр, Структура Точка, Структура Нормаль, Структура Материал)
        {
            double Расст = 0;
            var МинРасст = МАКС_ЧИСЛО;
            foreach (Структура Сф in Сферы)
            {
                if ((Сфера_Пересечение(Сф, Исх, Напр, Расст)) && (Расст < МинРасст))
                {
                    МинРасст = Расст;
                    Точка = Вектор_Сумма(Исх, Вектор_Умножить(Напр, Расст));
                    Нормаль = Вектор_Нормализация(Вектор_Разность(Точка, Сф.с.Центр));
                    Материал = Сф.с.Материал;
                }
            }
            // квадрат (-10,-10,-4) - (10,-30,-4)
            if (Напр.с.y < - 0.001)
            {
                var р = - (Исх.с.y + 4) / Напр.с.y;
                if (0 < р && р < МинРасст)
                {
                    var Т = Вектор_Умножить(Напр, р);
                    Т = Вектор_Сумма(Т, Исх);
                    if (Abs(Т.с.x) < 10 && - 30 < Т.с.z && Т.с.z < - 10)
                    {
                        МинРасст = р;
                        Точка = Т;
                        Нормаль = ЕдиничныйВекторY;
                        Материал = ((Цел(0.5 * Точка.с.x + 1000) + Цел(0.5 * Точка.с.z)) % 2 == 1 ? ПлиткаБелая : ПлиткаЖелтая);
                    }
                }
            }
            return МинРасст < 1000;
        } // НайтиПересечения()
    
        Структура Отражение(Структура Луч, Структура Норм)
        {
            return Вектор_Разность(Луч, Вектор_Умножить(Норм, 2 * Вектор_СкалярноеПр(Луч, Норм)));
        } // Отражение()
    
        Структура Преломление(Структура Луч, Структура Норм, double КоэфПр)
        {
            double эта; 
            Структура Н;
             
            if (КоэфПр == 1)
            {
                return Луч;
            }
            var CosI = - Макс(- 1, Мин(1, Вектор_СкалярноеПр(Луч, Норм)));
            if (CosI >= 0)
            {
                эта = 1 / КоэфПр;
                Н = Норм;
            }
            else
            {
                CosI = - CosI;
                эта = КоэфПр;
                Н = Вектор_Минус(Норм);
            }
            double К = 1 - эта * эта * (1 - CosI * CosI);
            if (К < 0)
            {
                return ЕдиничныйВекторX;
            }
            return Вектор_Сумма(Вектор_Умножить(Луч, эта), Вектор_Умножить(Н, эта * CosI - Sqrt(К)));
        } // Преломление()
    
        Структура ТрассироватьЛуч(Структура Исх, Структура Напр, int Глубина = 0)
        {
            Структура Точка = null;
            Структура Нормаль = null;
            Структура Материал = null;
            Структура ТеньТочка = null;
            Структура ТеньНормаль = null;
            Структура ВремМатериал = null;
            if (Глубина > ГЛУБИНА_РЕКУРСИИ || !(НайтиПересечения(Исх, Напр, Точка, Нормаль, Материал)))
            {
                return ЦветФона;
            }
            var СдвигПоНормали = Вектор_Умножить(Нормаль, 0.001);
            var ОтражНапр = Отражение(Напр, Нормаль);
            // нормализовано
            var ОтражИсх = (Вектор_СкалярноеПр(ОтражНапр, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
            var ОтражЦвет = ТрассироватьЛуч(ОтражИсх, ОтражНапр, Глубина + 1);
            var ПреломНапр = Вектор_Нормализация(Преломление(Напр, Нормаль, Материал.с.КПрелом));
            var ПреломИсх = (Вектор_СкалярноеПр(ПреломНапр, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
            var ПреломЦвет = ТрассироватьЛуч(ПреломИсх, ПреломНапр, Глубина + 1);
            var Яркость = 0;
            var Блик = 0;
            foreach (Структура Свет in Освещение)
            {
                var НапрКСвету = Вектор_Нормализация(Вектор_Разность(Свет.с.Поз, Точка));
                var РасстДоСвета = Вектор_КвНормы(Вектор_Разность(Свет.с.Поз, Точка));
                var ТеньИсх = (Вектор_СкалярноеПр(НапрКСвету, Нормаль) < 0 ? Вектор_Разность(Точка, СдвигПоНормали) : Вектор_Сумма(Точка, СдвигПоНормали));
                if (НайтиПересечения(ТеньИсх, НапрКСвету, ТеньТочка, ТеньНормаль, ВремМатериал) && Вектор_КвНормы(Вектор_Разность(ТеньТочка, ТеньИсх)) < РасстДоСвета)
                {
                    continue;
                }
                Яркость = Яркость + Свет.с.Ярк * Макс(0, Вектор_СкалярноеПр(НапрКСвету, Нормаль));
                //powf(std::max(0.f, -reflect(-light_dir, N)*dir), material.specular_exponent)*lights[i].intensity;
                Блик = Блик + Свет.с.Ярк * Pow(Макс(0, Вектор_СкалярноеПр(Отражение(НапрКСвету, Нормаль), Напр)), Материал.с.ЭкспОтраж);
            }
            return Вектор_Сумма(Вектор_Сумма(Вектор_Сумма(Вектор_Умножить(Материал.с.Цвет, Яркость * Материал.с.Альб0), Вектор_Умножить(ЕдиничныйВектор, Блик * Материал.с.Альб1)), Вектор_Умножить(ОтражЦвет, Материал.с.Альб2)), Вектор_Умножить(ПреломЦвет, Материал.с.Альб3));
        } // ТрассироватьЛуч()
    
        void Рендер()
        {
            var Камера = Новый_Вектор(0, 0, 0);
            var Напр_Z = - Высота / (2 * Tan(УголЗрения / 2));
            for (int верт = 0; верт <= Высота - 1; верт++)
            {
                int линия = верт * Ширина;
                var Напр_Y = - (верт + 0.5) + Высота / 2;
                for (int гор = 0; гор <= Ширина - 1; гор++)
                {
                    var Напр_X = (гор + 0.5) - Ширина / 2;
                    var Направление = Вектор_Нормализация(Новый_Вектор(Напр_X, Напр_Y, Напр_Z));
                    Кадр[линия + гор] = ТрассироватьЛуч(Камера, Направление);
                }
            }
        } // Рендер()
    
        void СохранитьКадр(string ИмяФайла)
        {
            var файл = Новый.ТекстовыйДокумент();
            файл.ДобавитьСтроку("P3");
            файл.ДобавитьСтроку("" + Ширина + " " + Высота);
            файл.ДобавитьСтроку("255");
            for (int п = 0; п <= Высота * Ширина - 1; п++)
            {
                var Пиксел = Кадр[п] as Структура;
                var МаксИнт = Макс(Пиксел.с.x, Макс(Пиксел.с.y, Пиксел.с.z));
                if (МаксИнт > 1)
                {
                    МаксИнт = 1 / МаксИнт;
                    Пиксел.с.x = Пиксел.с.x * МаксИнт;
                    Пиксел.с.y = Пиксел.с.y * МаксИнт;
                    Пиксел.с.z = Пиксел.с.z * МаксИнт;
                }
                файл.ДобавитьСтроку("" + Норм_Цвет(Пиксел.с.x) + " " + Норм_Цвет(Пиксел.с.y) + " " + Норм_Цвет(Пиксел.с.z));
            }
            файл.Записать(ИмяФайла, "ANSI");
        } // СохранитьКадр()
    
        
        public object УзелСвойство(Структура Узел, string Свойство)
        {
            object УзелСвойство = null;
            if (!(Узел == Неопределено))
            {
                Узел.Свойство(Свойство, out УзелСвойство);
            }
            return УзелСвойство;
        } // УзелСвойство(Узел)

        public Узел ИмяЗначение(string Имя = "", object _Значение = null)
        {
            var Значение = (_Значение is null) ? "" : _Значение;
            return Узел.Новый("Имя, Значение", Имя, Значение);
        }
    
        
        public string Кадр_Свойства(pagedata Данные, Узел оУзел)
        {
            object Свойства = null;
            var шСвойства = "";

            if (!(оУзел.Свойство("Свойства", out Свойства)))
            { // новый объект
                Свойства = Данные.НовыйДочерний(оУзел, ИмяЗначение("Свойства.", ""));
            }

            шСвойства = @"
            |*События";

            Данные.СоздатьСвойства(Свойства as Узел, шСвойства, "Только");
            оУзел.Вставить("Свойства", Свойства);

            return null;
        }


        public void Кадр_Модель(pagedata Данные, Узел Свойства, Соответствие Изменения)
        {
            var оУзел = Свойства.Родитель;

            // обработать события
            if (Изменения.Получить(Свойства.д.События) as bool? == Истина)
            {
                var дУзел = Свойства.д.События.Дочерний as Узел;
                if (!(дУзел is null))
                {
                    var мСобытие = Стр.Разделить(дУзел.Значение as string, Символы.Таб);
                    var тСобытие = мСобытие[0];
                    if (тСобытие == "ПриНажатии")
                    {
                        var сУзел = Данные.ПолучитьУзел(мСобытие[1]);

                        var ЗначениеКнопка = УзелСвойство(дУзел, "Параметры") as string;
                        if (!(ЗначениеКнопка is null))
                        {

                            if (ЗначениеКнопка == "sent")
                            {
                            }
                        }
                    }
                    else
                    { // изменение полей
                    }

                }

                Данные.УдалитьУзел(дУзел);
                Изменения.Вставить(Свойства.д.События, Истина);
                оУзел.Вставить("Обновить", Истина);
            }

            if (!(УзелСвойство(оУзел, "Обновить") as bool? == Ложь))
            {

                пи = 3.14159265359;
                МАКС_ЧИСЛО = 999999999999999;
                ГЛУБИНА_РЕКУРСИИ = 4;
                НулевойВектор = Новый_Вектор(0, 0, 0);
                ЕдиничныйВектор = Новый_Вектор(1, 1, 1);
                ЕдиничныйВекторX = Новый_Вектор(1, 0, 0);
                ЕдиничныйВекторY = Новый_Вектор(0, 1, 0);
                ЕдиничныйВекторZ = Новый_Вектор(0, 0, 1);
                ЦветБелый = ЕдиничныйВектор;
                ЦветЖелтый = Новый_Вектор(1, 0.7, 0.3);
                Ширина = 1024;
                Высота = 768;
                УголЗрения = пи / 3;
                Кадр = Новый.Массив(Ширина * Высота);
                ЦветФона = Новый_Вектор(0.2, 0.7, 0.8);
                var Серый = Новый_Материал(Новый_Вектор(0.4, 0.4, 0.3), 0.6, 0.3, 0.1, 0, 50, 1);
                var Стекло = Новый_Материал(Новый_Вектор(0.6, 0.7, 0.8), 0, 0.5, 0.1, 0.8, 125, 1.5);
                var Красный = Новый_Материал(Новый_Вектор(0.3, 0.1, 0.1), 0.9, 0.1, 0.0, 0, 10, 1);
                var Зеркало = Новый_Материал(Новый_Вектор(1.0, 1.0, 1.0), 0, 10.0, 0.8, 0, 1425, 1);
                ПлиткаБелая = Новый_Материал(Вектор_Умножить(ЦветБелый, 0.3), 1, 0, 0, 0, 0, 1);
                ПлиткаЖелтая = Новый_Материал(Вектор_Умножить(ЦветЖелтый, 0.3), 1, 0, 0, 0, 0, 1);
                Сферы = Новый.Массив();
                Сферы.Добавить(Новая_Сфера(Новый_Вектор(- 3, 0, - 16), 2, Серый));
                Сферы.Добавить(Новая_Сфера(Новый_Вектор(- 1.0, - 1.5, - 12), 2, Стекло));
                Сферы.Добавить(Новая_Сфера(Новый_Вектор(1.5, - 0.5, - 18), 3, Красный));
                Сферы.Добавить(Новая_Сфера(Новый_Вектор(7, 5, - 18), 4, Зеркало));
                Освещение = Новый.Массив();
                Освещение.Добавить(Новый_Свет(Новый_Вектор(- 20, 20, 20), 1.5));
                Освещение.Добавить(Новый_Свет(Новый_Вектор(30, 50, - 25), 1.8));
                Освещение.Добавить(Новый_Свет(Новый_Вектор(30, 20, 30), 1.7));
                var т0 = ТекущаяУниверсальнаяДатаВМиллисекундах();
                Рендер();
                var т1 = ТекущаяУниверсальнаяДатаВМиллисекундах();
                //сообщить("~"+ Цел(т1-т0) );
                СохранитьКадр(ОбъединитьПути(ТекущийКаталог(),"out.ppm"));

            }

        }

    }
}
